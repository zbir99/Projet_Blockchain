{"ast":null,"code":"import { Interface } from \"../abi/index.js\";\nimport { getCreateAddress } from \"../address/index.js\";\nimport { concat, defineProperties, getBytes, hexlify, assert, assertArgument } from \"../utils/index.js\";\nimport { BaseContract, copyOverrides, resolveArgs } from \"./contract.js\";\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\nexport class ContractFactory {\n  interface;\n  bytecode;\n  runner;\n  constructor(abi, bytecode, runner) {\n    const iface = Interface.from(abi);\n    // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n    if (bytecode instanceof Uint8Array) {\n      bytecode = hexlify(getBytes(bytecode));\n    } else {\n      if (typeof bytecode === \"object\") {\n        bytecode = bytecode.object;\n      }\n      if (bytecode.substring(0, 2) !== \"0x\") {\n        bytecode = \"0x\" + bytecode;\n      }\n      bytecode = hexlify(getBytes(bytecode));\n    }\n    defineProperties(this, {\n      bytecode,\n      interface: iface,\n      runner: runner || null\n    });\n  }\n  async getDeployTransaction(...args) {\n    let overrides = {};\n    const fragment = this.interface.deploy;\n    if (fragment.inputs.length + 1 === args.length) {\n      overrides = await copyOverrides(args.pop());\n    }\n    if (fragment.inputs.length !== args.length) {\n      throw new Error(\"incorrect number of arguments to constructor\");\n    }\n    const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);\n    const data = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);\n    return Object.assign({}, overrides, {\n      data\n    });\n  }\n  async deploy(...args) {\n    const tx = await this.getDeployTransaction(...args);\n    assert(this.runner && typeof this.runner.sendTransaction === \"function\", \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"sendTransaction\"\n    });\n    const sentTx = await this.runner.sendTransaction(tx);\n    const address = getCreateAddress(sentTx);\n    return new BaseContract(address, this.interface, this.runner, sentTx);\n  }\n  connect(runner) {\n    return new ContractFactory(this.interface, this.bytecode, runner);\n  }\n  static fromSolidity(output, runner) {\n    assertArgument(output != null, \"bad compiler output\", \"output\", output);\n    if (typeof output === \"string\") {\n      output = JSON.parse(output);\n    }\n    const abi = output.abi;\n    let bytecode = \"\";\n    if (output.bytecode) {\n      bytecode = output.bytecode;\n    } else if (output.evm && output.evm.bytecode) {\n      bytecode = output.evm.bytecode;\n    }\n    return new this(abi, bytecode, runner);\n  }\n}","map":{"version":3,"names":["Interface","getCreateAddress","concat","defineProperties","getBytes","hexlify","assert","assertArgument","BaseContract","copyOverrides","resolveArgs","ContractFactory","interface","bytecode","runner","constructor","abi","iface","from","Uint8Array","object","substring","getDeployTransaction","args","overrides","fragment","deploy","inputs","length","pop","Error","resolvedArgs","data","encodeDeploy","Object","assign","tx","sendTransaction","operation","sentTx","address","connect","fromSolidity","output","JSON","parse","evm"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\ethers\\src.ts\\contract\\factory.ts"],"sourcesContent":["\nimport { Interface } from \"../abi/index.js\";\nimport { getCreateAddress } from \"../address/index.js\";\nimport {\n    concat, defineProperties, getBytes, hexlify,\n    assert, assertArgument\n} from \"../utils/index.js\";\n\nimport { BaseContract, copyOverrides, resolveArgs } from \"./contract.js\";\n\nimport type { InterfaceAbi } from \"../abi/index.js\";\nimport type { ContractRunner } from \"../providers/index.js\";\nimport type { BytesLike } from \"../utils/index.js\";\n\nimport type {\n    ContractInterface, ContractMethodArgs, ContractDeployTransaction,\n} from \"./types.js\";\nimport type { ContractTransactionResponse } from \"./wrappers.js\";\n\n\n// A = Arguments to the constructor\n// I = Interface of deployed contracts\nexport class ContractFactory<A extends Array<any> = Array<any>, I = BaseContract> {\n    readonly interface!: Interface;\n    readonly bytecode!: string;\n    readonly runner!: null | ContractRunner;\n\n    constructor(abi: Interface | InterfaceAbi, bytecode: BytesLike | { object: string }, runner?: null | ContractRunner) {\n        const iface = Interface.from(abi);\n\n        // Dereference Solidity bytecode objects and allow a missing `0x`-prefix\n        if (bytecode instanceof Uint8Array) {\n            bytecode = hexlify(getBytes(bytecode));\n        } else {\n            if (typeof(bytecode) === \"object\") { bytecode = bytecode.object; }\n            if (bytecode.substring(0, 2) !== \"0x\") { bytecode = \"0x\" + bytecode; }\n            bytecode = hexlify(getBytes(bytecode));\n        }\n\n        defineProperties<ContractFactory>(this, {\n            bytecode, interface: iface, runner: (runner || null)\n        });\n    }\n\n    async getDeployTransaction(...args: ContractMethodArgs<A>): Promise<ContractDeployTransaction> {\n        let overrides: Omit<ContractDeployTransaction, \"data\"> = { };\n\n        const fragment = this.interface.deploy;\n\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n        }\n\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"incorrect number of arguments to constructor\");\n        }\n\n        const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);\n\n        const data = concat([ this.bytecode, this.interface.encodeDeploy(resolvedArgs) ]);\n        return Object.assign({ }, overrides, { data });\n    }\n\n    async deploy(...args: ContractMethodArgs<A>): Promise<BaseContract & { deploymentTransaction(): ContractTransactionResponse } & Omit<I, keyof BaseContract>> {\n        const tx = await this.getDeployTransaction(...args);\n\n        assert(this.runner && typeof(this.runner.sendTransaction) === \"function\",\n            \"factory runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"sendTransaction\" });\n\n        const sentTx = await this.runner.sendTransaction(tx);\n        const address = getCreateAddress(sentTx);\n        return new (<any>BaseContract)(address, this.interface, this.runner, sentTx);\n    }\n\n    connect(runner: null | ContractRunner): ContractFactory<A, I> {\n        return new ContractFactory(this.interface, this.bytecode, runner);\n    }\n\n    static fromSolidity<A extends Array<any> = Array<any>, I = ContractInterface>(output: any, runner?: ContractRunner): ContractFactory<A, I> {\n        assertArgument(output != null, \"bad compiler output\", \"output\", output);\n\n        if (typeof(output) === \"string\") { output = JSON.parse(output); }\n\n        const abi = output.abi;\n\n        let bytecode = \"\";\n        if (output.bytecode) {\n            bytecode = output.bytecode;\n        } else if (output.evm && output.evm.bytecode) {\n            bytecode = output.evm.bytecode;\n        }\n\n        return new this(abi, bytecode, runner);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}