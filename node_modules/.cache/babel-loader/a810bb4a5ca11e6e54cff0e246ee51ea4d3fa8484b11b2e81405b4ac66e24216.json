{"ast":null,"code":"import { Parser } from \"./parser.js\";\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\nconst parser = new Parser();\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input) {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n/** Parse IPv4 `input` into IPv6 with IPv4-mapped bytes, eg ::ffff:1.2.3.4 */\nexport function parseIPv4Mapped(input) {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n  const ipv4 = parser.new(input).parseWith(() => parser.readIPv4Addr());\n  if (ipv4 === undefined) {\n    return undefined;\n  }\n  return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, ipv4[0], ipv4[1], ipv4[2], ipv4[3]]);\n}\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input) {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input, mapIPv4ToIPv6 = false) {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n  const addr = parser.new(input).parseWith(() => parser.readIPAddr());\n  if (!addr) {\n    return undefined;\n  }\n  if (mapIPv4ToIPv6 && addr.length === 4) {\n    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, addr[0], addr[1], addr[2], addr[3]]);\n  }\n  return addr;\n}","map":{"version":3,"names":["Parser","MAX_IPV6_LENGTH","MAX_IPV4_LENGTH","parser","parseIPv4","input","length","undefined","new","parseWith","readIPv4Addr","parseIPv4Mapped","ipv4","Uint8Array","from","parseIPv6","includes","split","readIPv6Addr","parseIP","mapIPv4ToIPv6","addr","readIPAddr"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@chainsafe\\is-ip\\src\\parse.ts"],"sourcesContent":["import { Parser } from \"./parser.js\";\n\n// See https://stackoverflow.com/questions/166132/maximum-length-of-the-textual-representation-of-an-ipv6-address\nconst MAX_IPV6_LENGTH = 45;\nconst MAX_IPV4_LENGTH = 15;\n\nconst parser = new Parser();\n\n/** Parse `input` into IPv4 bytes. */\nexport function parseIPv4(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv4Addr());\n}\n\n/** Parse IPv4 `input` into IPv6 with IPv4-mapped bytes, eg ::ffff:1.2.3.4 */\nexport function parseIPv4Mapped(input: string): Uint8Array | undefined {\n  if (input.length > MAX_IPV4_LENGTH) {\n    return undefined;\n  }\n\n  const ipv4 = parser.new(input).parseWith(() => parser.readIPv4Addr());\n  if (ipv4 === undefined) {\n    return undefined;\n  }\n\n  return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, ipv4[0], ipv4[1], ipv4[2], ipv4[3]]);\n}\n\n/** Parse `input` into IPv6 bytes. */\nexport function parseIPv6(input: string): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n  return parser.new(input).parseWith(() => parser.readIPv6Addr());\n}\n\n/** Parse `input` into IPv4 or IPv6 bytes. */\nexport function parseIP(input: string, mapIPv4ToIPv6 = false): Uint8Array | undefined {\n  // strip zone index if it is present\n  if (input.includes(\"%\")) {\n    input = input.split(\"%\")[0];\n  }\n\n  if (input.length > MAX_IPV6_LENGTH) {\n    return undefined;\n  }\n\n  const addr = parser.new(input).parseWith(() => parser.readIPAddr());\n  if (!addr) {\n    return undefined;\n  }\n\n  if (mapIPv4ToIPv6 && addr.length === 4) {\n    return Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff, addr[0], addr[1], addr[2], addr[3]]);\n  }\n\n  return addr;\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,aAAa;AAEpC;AACA,MAAMC,eAAe,GAAG,EAAE;AAC1B,MAAMC,eAAe,GAAG,EAAE;AAE1B,MAAMC,MAAM,GAAG,IAAIH,MAAM,EAAE;AAE3B;AACA,OAAM,SAAUI,SAASA,CAACC,KAAa;EACrC,IAAIA,KAAK,CAACC,MAAM,GAAGJ,eAAe,EAAE;IAClC,OAAOK,SAAS;;EAElB,OAAOJ,MAAM,CAACK,GAAG,CAACH,KAAK,CAAC,CAACI,SAAS,CAAC,MAAMN,MAAM,CAACO,YAAY,EAAE,CAAC;AACjE;AAEA;AACA,OAAM,SAAUC,eAAeA,CAACN,KAAa;EAC3C,IAAIA,KAAK,CAACC,MAAM,GAAGJ,eAAe,EAAE;IAClC,OAAOK,SAAS;;EAGlB,MAAMK,IAAI,GAAGT,MAAM,CAACK,GAAG,CAACH,KAAK,CAAC,CAACI,SAAS,CAAC,MAAMN,MAAM,CAACO,YAAY,EAAE,CAAC;EACrE,IAAIE,IAAI,KAAKL,SAAS,EAAE;IACtB,OAAOA,SAAS;;EAGlB,OAAOM,UAAU,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAEF,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;AACxG;AAEA;AACA,OAAM,SAAUG,SAASA,CAACV,KAAa;EACrC;EACA,IAAIA,KAAK,CAACW,QAAQ,CAAC,GAAG,CAAC,EAAE;IACvBX,KAAK,GAAGA,KAAK,CAACY,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;EAE7B,IAAIZ,KAAK,CAACC,MAAM,GAAGL,eAAe,EAAE;IAClC,OAAOM,SAAS;;EAElB,OAAOJ,MAAM,CAACK,GAAG,CAACH,KAAK,CAAC,CAACI,SAAS,CAAC,MAAMN,MAAM,CAACe,YAAY,EAAE,CAAC;AACjE;AAEA;AACA,OAAM,SAAUC,OAAOA,CAACd,KAAa,EAAEe,aAAa,GAAG,KAAK;EAC1D;EACA,IAAIf,KAAK,CAACW,QAAQ,CAAC,GAAG,CAAC,EAAE;IACvBX,KAAK,GAAGA,KAAK,CAACY,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;EAG7B,IAAIZ,KAAK,CAACC,MAAM,GAAGL,eAAe,EAAE;IAClC,OAAOM,SAAS;;EAGlB,MAAMc,IAAI,GAAGlB,MAAM,CAACK,GAAG,CAACH,KAAK,CAAC,CAACI,SAAS,CAAC,MAAMN,MAAM,CAACmB,UAAU,EAAE,CAAC;EACnE,IAAI,CAACD,IAAI,EAAE;IACT,OAAOd,SAAS;;EAGlB,IAAIa,aAAa,IAAIC,IAAI,CAACf,MAAM,KAAK,CAAC,EAAE;IACtC,OAAOO,UAAU,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,IAAI,EAAEO,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;;EAGxG,OAAOA,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}