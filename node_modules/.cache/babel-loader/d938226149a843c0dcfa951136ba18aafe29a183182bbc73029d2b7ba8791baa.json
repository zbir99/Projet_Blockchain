{"ast":null,"code":"import { coerce } from '../bytes.js';\nimport basex from '../vendor/base-x.js';\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder {\n  name;\n  prefix;\n  baseEncode;\n  constructor(name, prefix, baseEncode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n  }\n  encode(bytes) {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`;\n    } else {\n      throw Error('Unknown type, must be binary type');\n    }\n  }\n}\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder {\n  name;\n  prefix;\n  baseDecode;\n  prefixCodePoint;\n  constructor(name, prefix, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    const prefixCodePoint = prefix.codePointAt(0);\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character');\n    }\n    this.prefixCodePoint = prefixCodePoint;\n    this.baseDecode = baseDecode;\n  }\n  decode(text) {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);\n      }\n      return this.baseDecode(text.slice(this.prefix.length));\n    } else {\n      throw Error('Can only multibase decode strings');\n    }\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n}\nclass ComposedDecoder {\n  decoders;\n  constructor(decoders) {\n    this.decoders = decoders;\n  }\n  or(decoder) {\n    return or(this, decoder);\n  }\n  decode(input) {\n    const prefix = input[0];\n    const decoder = this.decoders[prefix];\n    if (decoder != null) {\n      return decoder.decode(input);\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);\n    }\n  }\n}\nexport function or(left, right) {\n  return new ComposedDecoder({\n    ...(left.decoders ?? {\n      [left.prefix]: left\n    }),\n    ...(right.decoders ?? {\n      [right.prefix]: right\n    })\n  });\n}\nexport class Codec {\n  name;\n  prefix;\n  baseEncode;\n  baseDecode;\n  encoder;\n  decoder;\n  constructor(name, prefix, baseEncode, baseDecode) {\n    this.name = name;\n    this.prefix = prefix;\n    this.baseEncode = baseEncode;\n    this.baseDecode = baseDecode;\n    this.encoder = new Encoder(name, prefix, baseEncode);\n    this.decoder = new Decoder(name, prefix, baseDecode);\n  }\n  encode(input) {\n    return this.encoder.encode(input);\n  }\n  decode(input) {\n    return this.decoder.decode(input);\n  }\n}\nexport function from({\n  name,\n  prefix,\n  encode,\n  decode\n}) {\n  return new Codec(name, prefix, encode, decode);\n}\nexport function baseX({\n  name,\n  prefix,\n  alphabet\n}) {\n  const {\n    encode,\n    decode\n  } = basex(alphabet, name);\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: text => coerce(decode(text))\n  });\n}\nfunction decode(string, alphabetIdx, bitsPerChar, name) {\n  // Count the padding bytes:\n  let end = string.length;\n  while (string[end - 1] === '=') {\n    --end;\n  }\n  // Allocate the output:\n  const out = new Uint8Array(end * bitsPerChar / 8 | 0);\n  // Parse the data:\n  let bits = 0; // Number of bits currently in the buffer\n  let buffer = 0; // Bits waiting to be written out, MSB first\n  let written = 0; // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]];\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`);\n    }\n    // Append the bits to the buffer:\n    buffer = buffer << bitsPerChar | value;\n    bits += bitsPerChar;\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  }\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & buffer << 8 - bits) !== 0) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n  return out;\n}\nfunction encode(data, alphabet, bitsPerChar) {\n  const pad = alphabet[alphabet.length - 1] === '=';\n  const mask = (1 << bitsPerChar) - 1;\n  let out = '';\n  let bits = 0; // Number of bits currently in the buffer\n  let buffer = 0; // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | data[i];\n    bits += 8;\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar;\n      out += alphabet[mask & buffer >> bits];\n    }\n  }\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & buffer << bitsPerChar - bits];\n  }\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while ((out.length * bitsPerChar & 7) !== 0) {\n      out += '=';\n    }\n  }\n  return out;\n}\nfunction createAlphabetIdx(alphabet) {\n  // Build the character lookup table:\n  const alphabetIdx = {};\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i;\n  }\n  return alphabetIdx;\n}\n/**\n * RFC4648 Factory\n */\nexport function rfc4648({\n  name,\n  prefix,\n  bitsPerChar,\n  alphabet\n}) {\n  const alphabetIdx = createAlphabetIdx(alphabet);\n  return from({\n    prefix,\n    name,\n    encode(input) {\n      return encode(input, alphabet, bitsPerChar);\n    },\n    decode(input) {\n      return decode(input, alphabetIdx, bitsPerChar, name);\n    }\n  });\n}","map":{"version":3,"names":["coerce","basex","Encoder","name","prefix","baseEncode","constructor","encode","bytes","Uint8Array","Error","Decoder","baseDecode","prefixCodePoint","codePointAt","undefined","decode","text","JSON","stringify","slice","length","or","decoder","ComposedDecoder","decoders","input","RangeError","Object","keys","left","right","Codec","encoder","from","baseX","alphabet","string","alphabetIdx","bitsPerChar","end","out","bits","buffer","written","i","value","SyntaxError","data","pad","mask","createAlphabetIdx","rfc4648"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\multiformats\\src\\bases\\base.ts"],"sourcesContent":["import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,aAAa;AACpC,OAAOC,KAAK,MAAM,qBAAqB;AAMvC;;;;;AAKA,MAAMC,OAAO;EACFC,IAAI;EACJC,MAAM;EACNC,UAAU;EAEnBC,YAAaH,IAAU,EAAEC,MAAc,EAAEC,UAAoB;IAC3D,IAAI,CAACF,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC9B;EAEAE,MAAMA,CAAEC,KAAiB;IACvB,IAAIA,KAAK,YAAYC,UAAU,EAAE;MAC/B,OAAO,GAAG,IAAI,CAACL,MAAM,GAAG,IAAI,CAACC,UAAU,CAACG,KAAK,CAAC,EAAE;IAClD,CAAC,MAAM;MACL,MAAME,KAAK,CAAC,mCAAmC,CAAC;IAClD;EACF;;AAGF;;;;;AAKA,MAAMC,OAAO;EACFR,IAAI;EACJC,MAAM;EACNQ,UAAU;EACFC,eAAe;EAEhCP,YAAaH,IAAU,EAAEC,MAAc,EAAEQ,UAAoB;IAC3D,IAAI,CAACT,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,MAAMS,eAAe,GAAGT,MAAM,CAACU,WAAW,CAAC,CAAC,CAAC;IAC7C;IACA,IAAID,eAAe,KAAKE,SAAS,EAAE;MACjC,MAAM,IAAIL,KAAK,CAAC,0BAA0B,CAAC;IAC7C;IACA,IAAI,CAACG,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACD,UAAU,GAAGA,UAAU;EAC9B;EAEAI,MAAMA,CAAEC,IAAY;IAClB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC5B,IAAIA,IAAI,CAACH,WAAW,CAAC,CAAC,CAAC,KAAK,IAAI,CAACD,eAAe,EAAE;QAChD,MAAMH,KAAK,CAAC,qCAAqCQ,IAAI,CAACC,SAAS,CAACF,IAAI,CAAC,KAAK,IAAI,CAACd,IAAI,+CAA+C,IAAI,CAACC,MAAM,EAAE,CAAC;MAClJ;MACA,OAAO,IAAI,CAACQ,UAAU,CAACK,IAAI,CAACG,KAAK,CAAC,IAAI,CAAChB,MAAM,CAACiB,MAAM,CAAC,CAAC;IACxD,CAAC,MAAM;MACL,MAAMX,KAAK,CAAC,mCAAmC,CAAC;IAClD;EACF;EAEAY,EAAEA,CAA8BC,OAAmE;IACjG,OAAOD,EAAE,CAAC,IAAI,EAAEC,OAAO,CAAC;EAC1B;;AAKF,MAAMC,eAAe;EACVC,QAAQ;EAEjBnB,YAAamB,QAA0B;IACrC,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC1B;EAEAH,EAAEA,CAA+BC,OAAmE;IAClG,OAAOD,EAAE,CAAC,IAAI,EAAEC,OAAO,CAAC;EAC1B;EAEAP,MAAMA,CAAEU,KAAa;IACnB,MAAMtB,MAAM,GAAGsB,KAAK,CAAC,CAAC,CAAW;IACjC,MAAMH,OAAO,GAAG,IAAI,CAACE,QAAQ,CAACrB,MAAM,CAAC;IACrC,IAAImB,OAAO,IAAI,IAAI,EAAE;MACnB,OAAOA,OAAO,CAACP,MAAM,CAACU,KAAK,CAAC;IAC9B,CAAC,MAAM;MACL,MAAMC,UAAU,CAAC,qCAAqCT,IAAI,CAACC,SAAS,CAACO,KAAK,CAAC,+BAA+BE,MAAM,CAACC,IAAI,CAAC,IAAI,CAACJ,QAAQ,CAAC,gBAAgB,CAAC;IACvJ;EACF;;AAGF,OAAM,SAAUH,EAAEA,CAAuCQ,IAA6C,EAAEC,KAA8C;EACpJ,OAAO,IAAIP,eAAe,CAAC;IACzB,IAAIM,IAAI,CAACL,QAAQ,IAAI;MAAE,CAAEK,IAA0B,CAAC1B,MAAM,GAAG0B;IAAI,CAAE,CAAC;IACpE,IAAIC,KAAK,CAACN,QAAQ,IAAI;MAAE,CAAEM,KAA2B,CAAC3B,MAAM,GAAG2B;IAAK,CAAE;GACpD,CAAC;AACvB;AAEA,OAAM,MAAOC,KAAK;EACP7B,IAAI;EACJC,MAAM;EACNC,UAAU;EACVO,UAAU;EACVqB,OAAO;EACPV,OAAO;EAEhBjB,YAAaH,IAAU,EAAEC,MAAc,EAAEC,UAAoB,EAAEO,UAAoB;IACjF,IAAI,CAACT,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACO,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACqB,OAAO,GAAG,IAAI/B,OAAO,CAACC,IAAI,EAAEC,MAAM,EAAEC,UAAU,CAAC;IACpD,IAAI,CAACkB,OAAO,GAAG,IAAIZ,OAAO,CAACR,IAAI,EAAEC,MAAM,EAAEQ,UAAU,CAAC;EACtD;EAEAL,MAAMA,CAAEmB,KAAiB;IACvB,OAAO,IAAI,CAACO,OAAO,CAAC1B,MAAM,CAACmB,KAAK,CAAC;EACnC;EAEAV,MAAMA,CAAEU,KAAa;IACnB,OAAO,IAAI,CAACH,OAAO,CAACP,MAAM,CAACU,KAAK,CAAC;EACnC;;AAGF,OAAM,SAAUQ,IAAIA,CAA+C;EAAE/B,IAAI;EAAEC,MAAM;EAAEG,MAAM;EAAES;AAAM,CAAsE;EACrK,OAAO,IAAIgB,KAAK,CAAC7B,IAAI,EAAEC,MAAM,EAAEG,MAAM,EAAES,MAAM,CAAC;AAChD;AAEA,OAAM,SAAUmB,KAAKA,CAA+C;EAAEhC,IAAI;EAAEC,MAAM;EAAEgC;AAAQ,CAAoD;EAC9I,MAAM;IAAE7B,MAAM;IAAES;EAAM,CAAE,GAAGf,KAAK,CAACmC,QAAQ,EAAEjC,IAAI,CAAC;EAChD,OAAO+B,IAAI,CAAC;IACV9B,MAAM;IACND,IAAI;IACJI,MAAM;IACNS,MAAM,EAAGC,IAAY,IAAiBjB,MAAM,CAACgB,MAAM,CAACC,IAAI,CAAC;GAC1D,CAAC;AACJ;AAEA,SAASD,MAAMA,CAAEqB,MAAc,EAAEC,WAAmC,EAAEC,WAAmB,EAAEpC,IAAY;EACrG;EACA,IAAIqC,GAAG,GAAGH,MAAM,CAAChB,MAAM;EACvB,OAAOgB,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;IAC9B,EAAEA,GAAG;EACP;EAEA;EACA,MAAMC,GAAG,GAAG,IAAIhC,UAAU,CAAE+B,GAAG,GAAGD,WAAW,GAAG,CAAC,GAAI,CAAC,CAAC;EAEvD;EACA,IAAIG,IAAI,GAAG,CAAC,EAAC;EACb,IAAIC,MAAM,GAAG,CAAC,EAAC;EACf,IAAIC,OAAO,GAAG,CAAC,EAAC;EAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,GAAG,EAAE,EAAEK,CAAC,EAAE;IAC5B;IACA,MAAMC,KAAK,GAAGR,WAAW,CAACD,MAAM,CAACQ,CAAC,CAAC,CAAC;IACpC,IAAIC,KAAK,KAAK/B,SAAS,EAAE;MACvB,MAAM,IAAIgC,WAAW,CAAC,OAAO5C,IAAI,YAAY,CAAC;IAChD;IAEA;IACAwC,MAAM,GAAIA,MAAM,IAAIJ,WAAW,GAAIO,KAAK;IACxCJ,IAAI,IAAIH,WAAW;IAEnB;IACA,IAAIG,IAAI,IAAI,CAAC,EAAE;MACbA,IAAI,IAAI,CAAC;MACTD,GAAG,CAACG,OAAO,EAAE,CAAC,GAAG,IAAI,GAAID,MAAM,IAAID,IAAK;IAC1C;EACF;EAEA;EACA,IAAIA,IAAI,IAAIH,WAAW,IAAI,CAAC,IAAI,GAAII,MAAM,IAAK,CAAC,GAAGD,IAAM,MAAM,CAAC,EAAE;IAChE,MAAM,IAAIK,WAAW,CAAC,wBAAwB,CAAC;EACjD;EAEA,OAAON,GAAG;AACZ;AAEA,SAASlC,MAAMA,CAAEyC,IAAgB,EAAEZ,QAAgB,EAAEG,WAAmB;EACtE,MAAMU,GAAG,GAAGb,QAAQ,CAACA,QAAQ,CAACf,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG;EACjD,MAAM6B,IAAI,GAAG,CAAC,CAAC,IAAIX,WAAW,IAAI,CAAC;EACnC,IAAIE,GAAG,GAAG,EAAE;EAEZ,IAAIC,IAAI,GAAG,CAAC,EAAC;EACb,IAAIC,MAAM,GAAG,CAAC,EAAC;EACf,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,IAAI,CAAC3B,MAAM,EAAE,EAAEwB,CAAC,EAAE;IACpC;IACAF,MAAM,GAAIA,MAAM,IAAI,CAAC,GAAIK,IAAI,CAACH,CAAC,CAAC;IAChCH,IAAI,IAAI,CAAC;IAET;IACA,OAAOA,IAAI,GAAGH,WAAW,EAAE;MACzBG,IAAI,IAAIH,WAAW;MACnBE,GAAG,IAAIL,QAAQ,CAACc,IAAI,GAAIP,MAAM,IAAID,IAAK,CAAC;IAC1C;EACF;EAEA;EACA,IAAIA,IAAI,KAAK,CAAC,EAAE;IACdD,GAAG,IAAIL,QAAQ,CAACc,IAAI,GAAIP,MAAM,IAAKJ,WAAW,GAAGG,IAAM,CAAC;EAC1D;EAEA;EACA,IAAIO,GAAG,EAAE;IACP,OAAO,CAAER,GAAG,CAACpB,MAAM,GAAGkB,WAAW,GAAI,CAAC,MAAM,CAAC,EAAE;MAC7CE,GAAG,IAAI,GAAG;IACZ;EACF;EAEA,OAAOA,GAAG;AACZ;AAEA,SAASU,iBAAiBA,CAAEf,QAAgB;EAC1C;EACA,MAAME,WAAW,GAA2B,EAAE;EAC9C,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,QAAQ,CAACf,MAAM,EAAE,EAAEwB,CAAC,EAAE;IACxCP,WAAW,CAACF,QAAQ,CAACS,CAAC,CAAC,CAAC,GAAGA,CAAC;EAC9B;EACA,OAAOP,WAAW;AACpB;AAEA;;;AAGA,OAAM,SAAUc,OAAOA,CAA+C;EAAEjD,IAAI;EAAEC,MAAM;EAAEmC,WAAW;EAAEH;AAAQ,CAAyE;EAClL,MAAME,WAAW,GAAGa,iBAAiB,CAACf,QAAQ,CAAC;EAC/C,OAAOF,IAAI,CAAC;IACV9B,MAAM;IACND,IAAI;IACJI,MAAMA,CAAEmB,KAAiB;MACvB,OAAOnB,MAAM,CAACmB,KAAK,EAAEU,QAAQ,EAAEG,WAAW,CAAC;IAC7C,CAAC;IACDvB,MAAMA,CAAEU,KAAa;MACnB,OAAOV,MAAM,CAACU,KAAK,EAAEY,WAAW,EAAEC,WAAW,EAAEpC,IAAI,CAAC;IACtD;GACD,CAAC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}