{"ast":null,"code":"import http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\nimport { assert } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\n/**\n *  @_ignore:\n */\nexport async function getUrl(req, signal) {\n  const protocol = req.url.split(\":\")[0].toLowerCase();\n  assert(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${protocol}`, \"UNSUPPORTED_OPERATION\", {\n    info: {\n      protocol\n    },\n    operation: \"request\"\n  });\n  assert(!req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"request\"\n  });\n  const method = req.method;\n  const headers = Object.assign({}, req.headers);\n  const options = {\n    method,\n    headers\n  };\n  const request = (protocol === \"http\" ? http : https).request(req.url, options);\n  request.setTimeout(req.timeout);\n  const body = req.body;\n  if (body) {\n    request.write(Buffer.from(body));\n  }\n  request.end();\n  return new Promise((resolve, reject) => {\n    // @TODO: Node 15 added AbortSignal; once we drop support for\n    // Node14, we can add that in here too\n    request.once(\"response\", resp => {\n      const statusCode = resp.statusCode || 0;\n      const statusMessage = resp.statusMessage || \"\";\n      const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {\n        let value = resp.headers[name] || \"\";\n        if (Array.isArray(value)) {\n          value = value.join(\", \");\n        }\n        accum[name] = value;\n        return accum;\n      }, {});\n      let body = null;\n      //resp.setEncoding(\"utf8\");\n      resp.on(\"data\", chunk => {\n        if (signal) {\n          try {\n            signal.checkSignal();\n          } catch (error) {\n            return reject(error);\n          }\n        }\n        if (body == null) {\n          body = chunk;\n        } else {\n          const newBody = new Uint8Array(body.length + chunk.length);\n          newBody.set(body, 0);\n          newBody.set(chunk, body.length);\n          body = newBody;\n        }\n      });\n      resp.on(\"end\", () => {\n        if (headers[\"content-encoding\"] === \"gzip\" && body) {\n          body = getBytes(gunzipSync(body));\n        }\n        resolve({\n          statusCode,\n          statusMessage,\n          headers,\n          body\n        });\n      });\n      resp.on(\"error\", error => {\n        //@TODO: Should this just return nornal response with a server error?\n        error.response = {\n          statusCode,\n          statusMessage,\n          headers,\n          body\n        };\n        reject(error);\n      });\n    });\n    request.on(\"error\", error => {\n      reject(error);\n    });\n  });\n}","map":{"version":3,"names":["http","https","gunzipSync","assert","getBytes","getUrl","req","signal","protocol","url","split","toLowerCase","info","operation","credentials","allowInsecureAuthentication","method","headers","Object","assign","options","request","setTimeout","timeout","body","write","Buffer","from","end","Promise","resolve","reject","once","resp","statusCode","statusMessage","keys","reduce","accum","name","value","Array","isArray","join","on","chunk","checkSignal","error","newBody","Uint8Array","length","set","response"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\ethers\\src.ts\\utils\\geturl.ts"],"sourcesContent":["import http from \"http\";\nimport https from \"https\";\nimport { gunzipSync } from \"zlib\";\n\nimport { assert } from \"./errors.js\";\nimport { getBytes } from \"./data.js\";\n\nimport type { FetchRequest, FetchCancelSignal, GetUrlResponse } from \"./fetch.js\";\n\n/**\n *  @_ignore:\n */\nexport async function getUrl(req: FetchRequest, signal?: FetchCancelSignal): Promise<GetUrlResponse> {\n\n    const protocol = req.url.split(\":\")[0].toLowerCase();\n\n    assert(protocol === \"http\" || protocol === \"https\", `unsupported protocol ${ protocol }`, \"UNSUPPORTED_OPERATION\", {\n        info: { protocol },\n        operation: \"request\"\n    });\n\n    assert(!req.credentials || req.allowInsecureAuthentication, \"insecure authorized connections unsupported\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"request\"\n    });\n\n    const method = req.method;\n    const headers = Object.assign({ }, req.headers);\n\n    const options: any = { method, headers };\n\n    const request = ((protocol === \"http\") ? http: https).request(req.url, options);\n\n    request.setTimeout(req.timeout);\n\n    const body = req.body;\n    if (body) { request.write(Buffer.from(body)); }\n\n    request.end();\n\n    return new Promise((resolve, reject) => {\n        // @TODO: Node 15 added AbortSignal; once we drop support for\n        // Node14, we can add that in here too\n\n        request.once(\"response\", (resp: http.IncomingMessage) => {\n            const statusCode = resp.statusCode || 0;\n            const statusMessage = resp.statusMessage || \"\";\n            const headers = Object.keys(resp.headers || {}).reduce((accum, name) => {\n                let value = resp.headers[name] || \"\";\n                if (Array.isArray(value)) {\n                    value = value.join(\", \");\n                }\n                accum[name] = value;\n                return accum;\n            }, <{ [ name: string ]: string }>{ });\n\n            let body: null | Uint8Array = null;\n            //resp.setEncoding(\"utf8\");\n\n            resp.on(\"data\", (chunk: Uint8Array) => {\n                if (signal) {\n                    try {\n                        signal.checkSignal();\n                    } catch (error) {\n                        return reject(error);\n                    }\n                }\n\n                if (body == null) {\n                    body = chunk;\n                } else {\n                    const newBody = new Uint8Array(body.length + chunk.length);\n                    newBody.set(body, 0);\n                    newBody.set(chunk, body.length);\n                    body = newBody;\n                }\n            });\n\n            resp.on(\"end\", () => {\n                if (headers[\"content-encoding\"] === \"gzip\" && body) {\n                    body = getBytes(gunzipSync(body));\n                }\n\n                resolve({ statusCode, statusMessage, headers, body });\n            });\n\n            resp.on(\"error\", (error) => {\n            //@TODO: Should this just return nornal response with a server error?\n                (<any>error).response = { statusCode, statusMessage, headers, body };\n                reject(error);\n            });\n        });\n\n        request.on(\"error\", (error) => { reject(error); });\n    });\n}\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}