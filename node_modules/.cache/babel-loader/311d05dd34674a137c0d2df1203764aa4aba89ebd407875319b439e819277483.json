{"ast":null,"code":"import { PollingEventSubscriber } from \"./subscriber-polling.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber {\n  #provider;\n  #filterIdPromise;\n  #poller;\n  #network;\n  #hault;\n  constructor(provider) {\n    this.#provider = provider;\n    this.#filterIdPromise = null;\n    this.#poller = this.#poll.bind(this);\n    this.#network = null;\n    this.#hault = false;\n  }\n  _subscribe(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  _emitResults(provider, result) {\n    throw new Error(\"subclasses must override this\");\n  }\n  _recover(provider) {\n    throw new Error(\"subclasses must override this\");\n  }\n  async #poll(blockNumber) {\n    try {\n      if (this.#filterIdPromise == null) {\n        this.#filterIdPromise = this._subscribe(this.#provider);\n      }\n      const filterId = await this.#filterIdPromise;\n      if (filterId == null) {\n        this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n        return;\n      }\n      const network = await this.#provider.getNetwork();\n      if (!this.#network) {\n        this.#network = network;\n      }\n      if (this.#network.chainId !== network.chainId) {\n        throw new Error(\"chaid changed\");\n      }\n      if (this.#hault) {\n        return;\n      }\n      const result = await this.#provider.send(\"eth_getFilterChanges\", [filterId]);\n      await this._emitResults(this.#provider, result);\n    } catch (error) {\n      console.log(\"@TODO\", error);\n    }\n    this.#provider.once(\"block\", this.#poller);\n  }\n  #teardown() {\n    const filterIdPromise = this.#filterIdPromise;\n    if (filterIdPromise) {\n      this.#filterIdPromise = null;\n      filterIdPromise.then(filterId => {\n        this.#provider.send(\"eth_uninstallFilter\", [filterId]);\n      });\n    }\n  }\n  start() {\n    this.#poll(-2);\n  }\n  stop() {\n    this.#hault = true;\n    this.#teardown();\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    if (dropWhilePaused) {\n      this.#teardown();\n    }\n    this.#provider.off(\"block\", this.#poller);\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n  #event;\n  constructor(provider, filter) {\n    super(provider);\n    this.#event = copy(filter);\n  }\n  _recover(provider) {\n    return new PollingEventSubscriber(provider, this.#event);\n  }\n  async _subscribe(provider) {\n    const filterId = await provider.send(\"eth_newFilter\", [this.#event]);\n    return filterId;\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(this.#event, provider._wrapLog(result, provider._network));\n    }\n  }\n}\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n  async _subscribe(provider) {\n    return await provider.send(\"eth_newPendingTransactionFilter\", []);\n  }\n  async _emitResults(provider, results) {\n    for (const result of results) {\n      provider.emit(\"pending\", result);\n    }\n  }\n}","map":{"version":3,"names":["PollingEventSubscriber","copy","obj","JSON","parse","stringify","FilterIdSubscriber","provider","filterIdPromise","poller","network","hault","constructor","poll","bind","_subscribe","Error","_emitResults","result","_recover","#poll","blockNumber","filterId","_recoverSubscriber","getNetwork","chainId","send","error","console","log","once","teardown","#teardown","then","start","stop","off","pause","dropWhilePaused","resume","FilterIdEventSubscriber","event","filter","results","emit","_wrapLog","_network","FilterIdPendingSubscriber"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\ethers\\src.ts\\providers\\subscriber-filterid.ts"],"sourcesContent":["import { PollingEventSubscriber } from \"./subscriber-polling.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { Network } from \"./network.js\";\nimport type { EventFilter } from \"./provider.js\";\nimport type { JsonRpcApiProvider } from \"./provider-jsonrpc.js\";\n\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  Some backends support subscribing to events using a Filter ID.\n *\n *  When subscribing with this technique, the node issues a unique\n *  //Filter ID//. At this point the node dedicates resources to\n *  the filter, so that periodic calls to follow up on the //Filter ID//\n *  will receive any events since the last call.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdSubscriber implements Subscriber {\n    #provider: JsonRpcApiProvider;\n\n    #filterIdPromise: null | Promise<string>;\n    #poller: (b: number) => Promise<void>;\n\n    #network: null | Network;\n\n    #hault: boolean;\n\n    constructor(provider: JsonRpcApiProvider) {\n        this.#provider = provider;\n\n        this.#filterIdPromise = null;\n        this.#poller = this.#poll.bind(this);\n\n        this.#network = null;\n\n        this.#hault = false;\n    }\n\n    _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    _emitResults(provider: AbstractProvider, result: Array<any>): Promise<void> {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    _recover(provider: AbstractProvider): Subscriber {\n        throw new Error(\"subclasses must override this\");\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        try {\n            if (this.#filterIdPromise == null) {\n                this.#filterIdPromise = this._subscribe(this.#provider);\n            }\n\n            const filterId = await this.#filterIdPromise;\n            if (filterId == null) {\n                this.#provider._recoverSubscriber(this, this._recover(this.#provider));\n                return;\n            }\n\n            const network = await this.#provider.getNetwork();\n            if (!this.#network) { this.#network = network; }\n\n            if ((this.#network as Network).chainId !== network.chainId) {\n                throw new Error(\"chaid changed\");\n            }\n\n            if (this.#hault) { return; }\n\n            const result = await this.#provider.send(\"eth_getFilterChanges\", [ filterId ]);\n            await this._emitResults(this.#provider, result);\n        } catch (error) { console.log(\"@TODO\", error); }\n\n        this.#provider.once(\"block\", this.#poller);\n    }\n\n    #teardown(): void {\n        const filterIdPromise = this.#filterIdPromise;\n        if (filterIdPromise) {\n            this.#filterIdPromise = null;\n            filterIdPromise.then((filterId) => {\n                this.#provider.send(\"eth_uninstallFilter\", [ filterId ]);\n            });\n        }\n    }\n\n    start(): void { this.#poll(-2); }\n\n    stop(): void {\n        this.#hault = true;\n        this.#teardown();\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        if (dropWhilePaused){ this.#teardown(); }\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    resume(): void { this.start(); }\n}\n\n/**\n *  A **FilterIdSubscriber** for receiving contract events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdEventSubscriber extends FilterIdSubscriber {\n    #event: EventFilter;\n\n    constructor(provider: JsonRpcApiProvider, filter: EventFilter) {\n        super(provider);\n        this.#event = copy(filter);\n    }\n\n    _recover(provider: AbstractProvider): Subscriber {\n        return new PollingEventSubscriber(provider, this.#event);\n    }\n\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        const filterId = await provider.send(\"eth_newFilter\", [ this.#event ]);\n        return filterId;\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Promise<void> {\n        for (const result of results) {\n            provider.emit(this.#event, provider._wrapLog(result, provider._network));\n        }\n    }\n}\n\n/**\n *  A **FilterIdSubscriber** for receiving pending transactions events.\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class FilterIdPendingSubscriber extends FilterIdSubscriber {\n    async _subscribe(provider: JsonRpcApiProvider): Promise<string> {\n        return await provider.send(\"eth_newPendingTransactionFilter\", [ ]);\n    }\n\n    async _emitResults(provider: JsonRpcApiProvider, results: Array<any>): Promise<void> {\n        for (const result of results) {\n            provider.emit(\"pending\", result);\n        }\n    }\n}\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,yBAAyB;AAQhE,SAASC,IAAIA,CAACC,GAAQ;EAClB,OAAOC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACH,GAAG,CAAC,CAAC;AAC1C;AAEA;;;;;;;;;;AAUA,OAAM,MAAOI,kBAAkB;EAC3B,CAAAC,QAAS;EAET,CAAAC,eAAgB;EAChB,CAAAC,MAAO;EAEP,CAAAC,OAAQ;EAER,CAAAC,KAAM;EAENC,YAAYL,QAA4B;IACpC,IAAI,CAAC,CAAAA,QAAS,GAAGA,QAAQ;IAEzB,IAAI,CAAC,CAAAC,eAAgB,GAAG,IAAI;IAC5B,IAAI,CAAC,CAAAC,MAAO,GAAG,IAAI,CAAC,CAAAI,IAAK,CAACC,IAAI,CAAC,IAAI,CAAC;IAEpC,IAAI,CAAC,CAAAJ,OAAQ,GAAG,IAAI;IAEpB,IAAI,CAAC,CAAAC,KAAM,GAAG,KAAK;EACvB;EAEAI,UAAUA,CAACR,QAA4B;IACnC,MAAM,IAAIS,KAAK,CAAC,+BAA+B,CAAC;EACpD;EAEAC,YAAYA,CAACV,QAA0B,EAAEW,MAAkB;IACvD,MAAM,IAAIF,KAAK,CAAC,+BAA+B,CAAC;EACpD;EAEAG,QAAQA,CAACZ,QAA0B;IAC/B,MAAM,IAAIS,KAAK,CAAC,+BAA+B,CAAC;EACpD;EAEA,MAAM,CAAAH,IAAKO,CAACC,WAAmB;IAC3B,IAAI;MACA,IAAI,IAAI,CAAC,CAAAb,eAAgB,IAAI,IAAI,EAAE;QAC/B,IAAI,CAAC,CAAAA,eAAgB,GAAG,IAAI,CAACO,UAAU,CAAC,IAAI,CAAC,CAAAR,QAAS,CAAC;;MAG3D,MAAMe,QAAQ,GAAG,MAAM,IAAI,CAAC,CAAAd,eAAgB;MAC5C,IAAIc,QAAQ,IAAI,IAAI,EAAE;QAClB,IAAI,CAAC,CAAAf,QAAS,CAACgB,kBAAkB,CAAC,IAAI,EAAE,IAAI,CAACJ,QAAQ,CAAC,IAAI,CAAC,CAAAZ,QAAS,CAAC,CAAC;QACtE;;MAGJ,MAAMG,OAAO,GAAG,MAAM,IAAI,CAAC,CAAAH,QAAS,CAACiB,UAAU,EAAE;MACjD,IAAI,CAAC,IAAI,CAAC,CAAAd,OAAQ,EAAE;QAAE,IAAI,CAAC,CAAAA,OAAQ,GAAGA,OAAO;;MAE7C,IAAK,IAAI,CAAC,CAAAA,OAAoB,CAACe,OAAO,KAAKf,OAAO,CAACe,OAAO,EAAE;QACxD,MAAM,IAAIT,KAAK,CAAC,eAAe,CAAC;;MAGpC,IAAI,IAAI,CAAC,CAAAL,KAAM,EAAE;QAAE;;MAEnB,MAAMO,MAAM,GAAG,MAAM,IAAI,CAAC,CAAAX,QAAS,CAACmB,IAAI,CAAC,sBAAsB,EAAE,CAAEJ,QAAQ,CAAE,CAAC;MAC9E,MAAM,IAAI,CAACL,YAAY,CAAC,IAAI,CAAC,CAAAV,QAAS,EAAEW,MAAM,CAAC;KAClD,CAAC,OAAOS,KAAK,EAAE;MAAEC,OAAO,CAACC,GAAG,CAAC,OAAO,EAAEF,KAAK,CAAC;;IAE7C,IAAI,CAAC,CAAApB,QAAS,CAACuB,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAArB,MAAO,CAAC;EAC9C;EAEA,CAAAsB,QAASC,CAAA;IACL,MAAMxB,eAAe,GAAG,IAAI,CAAC,CAAAA,eAAgB;IAC7C,IAAIA,eAAe,EAAE;MACjB,IAAI,CAAC,CAAAA,eAAgB,GAAG,IAAI;MAC5BA,eAAe,CAACyB,IAAI,CAAEX,QAAQ,IAAI;QAC9B,IAAI,CAAC,CAAAf,QAAS,CAACmB,IAAI,CAAC,qBAAqB,EAAE,CAAEJ,QAAQ,CAAE,CAAC;MAC5D,CAAC,CAAC;;EAEV;EAEAY,KAAKA,CAAA;IAAW,IAAI,CAAC,CAAArB,IAAK,CAAC,CAAC,CAAC,CAAC;EAAE;EAEhCsB,IAAIA,CAAA;IACA,IAAI,CAAC,CAAAxB,KAAM,GAAG,IAAI;IAClB,IAAI,CAAC,CAAAoB,QAAS,EAAE;IAChB,IAAI,CAAC,CAAAxB,QAAS,CAAC6B,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAA3B,MAAO,CAAC;EAC7C;EAEA4B,KAAKA,CAACC,eAAyB;IAC3B,IAAIA,eAAe,EAAC;MAAE,IAAI,CAAC,CAAAP,QAAS,EAAE;;IACtC,IAAI,CAAC,CAAAxB,QAAS,CAAC6B,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAA3B,MAAO,CAAC;EAC7C;EAEA8B,MAAMA,CAAA;IAAW,IAAI,CAACL,KAAK,EAAE;EAAE;;AAGnC;;;;;AAKA,OAAM,MAAOM,uBAAwB,SAAQlC,kBAAkB;EAC3D,CAAAmC,KAAM;EAEN7B,YAAYL,QAA4B,EAAEmC,MAAmB;IACzD,KAAK,CAACnC,QAAQ,CAAC;IACf,IAAI,CAAC,CAAAkC,KAAM,GAAGxC,IAAI,CAACyC,MAAM,CAAC;EAC9B;EAEAvB,QAAQA,CAACZ,QAA0B;IAC/B,OAAO,IAAIP,sBAAsB,CAACO,QAAQ,EAAE,IAAI,CAAC,CAAAkC,KAAM,CAAC;EAC5D;EAEA,MAAM1B,UAAUA,CAACR,QAA4B;IACzC,MAAMe,QAAQ,GAAG,MAAMf,QAAQ,CAACmB,IAAI,CAAC,eAAe,EAAE,CAAE,IAAI,CAAC,CAAAe,KAAM,CAAE,CAAC;IACtE,OAAOnB,QAAQ;EACnB;EAEA,MAAML,YAAYA,CAACV,QAA4B,EAAEoC,OAAmB;IAChE,KAAK,MAAMzB,MAAM,IAAIyB,OAAO,EAAE;MAC1BpC,QAAQ,CAACqC,IAAI,CAAC,IAAI,CAAC,CAAAH,KAAM,EAAElC,QAAQ,CAACsC,QAAQ,CAAC3B,MAAM,EAAEX,QAAQ,CAACuC,QAAQ,CAAC,CAAC;;EAEhF;;AAGJ;;;;;AAKA,OAAM,MAAOC,yBAA0B,SAAQzC,kBAAkB;EAC7D,MAAMS,UAAUA,CAACR,QAA4B;IACzC,OAAO,MAAMA,QAAQ,CAACmB,IAAI,CAAC,iCAAiC,EAAE,EAAG,CAAC;EACtE;EAEA,MAAMT,YAAYA,CAACV,QAA4B,EAAEoC,OAAmB;IAChE,KAAK,MAAMzB,MAAM,IAAIyB,OAAO,EAAE;MAC1BpC,QAAQ,CAACqC,IAAI,CAAC,SAAS,EAAE1B,MAAM,CAAC;;EAExC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}