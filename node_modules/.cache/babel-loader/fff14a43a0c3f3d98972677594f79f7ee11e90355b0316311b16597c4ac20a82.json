{"ast":null,"code":"/**\n * Service IPFS pour IPFS Desktop\n * Optimis√© pour fonctionner avec votre configuration\n */\nimport { create } from 'ipfs-http-client';\nclass IPFSService {\n  constructor() {\n    this.client = null;\n    this.isConnected = false;\n    this.serviceName = 'IPFS Desktop';\n    this.initialize();\n  }\n\n  /**\n   * Initialise la connexion IPFS Desktop\n   */\n  async initialize() {\n    try {\n      // Configuration pour IPFS Desktop\n      this.client = create({\n        host: 'localhost',\n        port: 5001,\n        protocol: 'http'\n      });\n\n      // Tester la connexion\n      const version = await this.client.version();\n      this.isConnected = true;\n      console.log('‚úÖ IPFS Desktop connect√© avec succ√®s!');\n      console.log('üì¶ Version IPFS:', version.version);\n      console.log('üîç Service:', this.serviceName);\n    } catch (error) {\n      console.error('‚ùå Connexion √©chou√©e √† IPFS Desktop:', error.message);\n      console.log('üîß Solutions possibles:');\n      console.log('1. V√©rifiez que IPFS Desktop est d√©marr√©');\n      console.log('2. V√©rifiez la configuration CORS dans les param√®tres de IPFS Desktop');\n      console.log('3. Red√©marrez IPFS Desktop');\n      this.isConnected = false;\n    }\n  }\n\n  /**\n   * V√©rifie la connexion √† IPFS Desktop\n   */\n  async checkConnection() {\n    try {\n      if (!this.client) {\n        await this.initialize();\n      }\n      const version = await this.client.version();\n      this.isConnected = true;\n      return true;\n    } catch (error) {\n      console.error('‚ùå IPFS Desktop non accessible:', error.message);\n      this.isConnected = false;\n      return false;\n    }\n  }\n\n  /**\n   * Upload un fichier sur IPFS Desktop\n   * @param {File} file - Le fichier √† uploader\n   * @returns {Promise<string>} - Le hash IPFS\n   */\n  async uploadFile(file) {\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    console.log('üì§ Upload sur IPFS Desktop...');\n    console.log('üìÑ Fichier:', file.name);\n    console.log('üìä Taille:', (file.size / 1024 / 1024).toFixed(2), 'MB');\n\n    // V√©rifier la connexion\n    const isConnected = await this.checkConnection();\n    if (!isConnected) {\n      throw new Error('IPFS Desktop non disponible. V√©rifiez qu\\'il est bien d√©marr√©.');\n    }\n    try {\n      // Convertir le fichier en ArrayBuffer puis Uint8Array\n      const arrayBuffer = await file.arrayBuffer();\n      const fileContent = new Uint8Array(arrayBuffer);\n      console.log('‚è≥ Upload en cours...');\n\n      // Upload sur IPFS avec gestion du progr√®s\n      const result = await this.client.add({\n        path: file.name,\n        content: fileContent\n      }, {\n        pin: true,\n        // √âpingler pour √©viter la suppression\n        progress: bytes => {\n          const percent = (bytes / file.size * 100).toFixed(1);\n          console.log(`üìä Progression: ${percent}% (${bytes}/${file.size} bytes)`);\n        }\n      });\n      const ipfsHash = result.cid.toString();\n      console.log('‚úÖ Upload r√©ussi sur IPFS Desktop!');\n      console.log('üîó Hash IPFS:', ipfsHash);\n      console.log('üåê URL:', this.getGatewayURL(ipfsHash));\n\n      // V√©rifier que le fichier est accessible\n      setTimeout(async () => {\n        try {\n          const isAccessible = await this.verifyFileAccess(ipfsHash);\n          console.log(isAccessible ? '‚úÖ Fichier accessible via gateway' : '‚ö†Ô∏è Fichier pas encore accessible');\n        } catch (error) {\n          console.warn('‚ö†Ô∏è V√©rification d\\'acc√®s √©chou√©e:', error.message);\n        }\n      }, 1000);\n      return ipfsHash;\n    } catch (error) {\n      console.error('‚ùå Erreur upload sur IPFS Desktop:', error);\n\n      // Messages d'erreur sp√©cifiques\n      if (error.code === 'ECONNREFUSED') {\n        throw new Error('IPFS Desktop non accessible. V√©rifiez qu\\'il est bien d√©marr√©.');\n      } else if (error.message.includes('fetch') || error.message.includes('CORS')) {\n        throw new Error('Erreur CORS. V√©rifiez la configuration CORS dans les param√®tres de IPFS Desktop.');\n      } else {\n        throw new Error(`Erreur upload: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Upload des donn√©es JSON sur IPFS Desktop\n   * @param {Object} data - Les donn√©es √† uploader\n   * @returns {Promise<string>} - Le hash IPFS\n   */\n  async uploadJSON(data) {\n    console.log('üì§ Upload JSON sur IPFS Desktop...');\n    console.log('üìÑ Donn√©es:', data);\n    const isConnected = await this.checkConnection();\n    if (!isConnected) {\n      throw new Error('IPFS Desktop non disponible');\n    }\n    try {\n      const jsonString = JSON.stringify(data, null, 2);\n      console.log('üìù JSON format√©:', jsonString.length, 'caract√®res');\n      const result = await this.client.add(jsonString, {\n        pin: true,\n        timeout: 10000 // 10 secondes de timeout\n      });\n      const ipfsHash = result.cid.toString();\n      console.log('‚úÖ JSON upload√© avec succ√®s!');\n      console.log('üîó Hash IPFS:', ipfsHash);\n      return ipfsHash;\n    } catch (error) {\n      console.error('‚ùå Erreur upload JSON:', error);\n      throw new Error(`Erreur upload JSON sur IPFS Desktop: ${error.message}`);\n    }\n  }\n\n  /**\n   * V√©rifie qu'un fichier est accessible via la gateway\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {Promise<boolean>} - True si accessible\n   */\n  async verifyFileAccess(ipfsHash) {\n    try {\n      const url = this.getGatewayURL(ipfsHash);\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 5000);\n      const response = await fetch(url, {\n        method: 'HEAD',\n        signal: controller.signal\n      });\n      clearTimeout(timeoutId);\n      return response.ok;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * URL de la gateway IPFS pour IPFS Desktop\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {string} - L'URL compl√®te\n   */\n  getGatewayURL(ipfsHash) {\n    if (!ipfsHash) return '';\n    return `http://localhost:8080/ipfs/${ipfsHash}`;\n  }\n\n  /**\n   * Informations sur un fichier IPFS\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {Promise<Object>} - Les informations du fichier\n   */\n  async getFileInfo(ipfsHash) {\n    if (!this.isConnected) {\n      throw new Error('IPFS Desktop non connect√©');\n    }\n    try {\n      // Essayer de r√©cup√©rer les stats via l'API\n      const stats = await this.client.object.stat(ipfsHash);\n      return {\n        hash: ipfsHash,\n        size: stats.CumulativeSize || stats.DataSize || 0,\n        links: stats.NumLinks || 0,\n        url: this.getGatewayURL(ipfsHash),\n        accessible: true,\n        service: this.serviceName\n      };\n    } catch (error) {\n      return {\n        hash: ipfsHash,\n        size: 0,\n        links: 0,\n        url: this.getGatewayURL(ipfsHash),\n        accessible: false,\n        error: error.message,\n        service: this.serviceName\n      };\n    }\n  }\n\n  /**\n   * Statut du service IPFS Desktop\n   * @returns {Object} - Informations d√©taill√©es\n   */\n  getStatus() {\n    return {\n      connected: this.isConnected,\n      service: this.serviceName,\n      type: 'Desktop',\n      host: 'localhost',\n      apiPort: 5001,\n      gatewayPort: 8080,\n      protocol: 'http',\n      apiUrl: 'http://localhost:5001',\n      gatewayUrl: 'http://localhost:8080',\n      webuiUrl: 'http://localhost:5001/webui'\n    };\n  }\n\n  /**\n   * Diagnostic complet de IPFS Desktop\n   * @returns {Promise<Object>} - R√©sultats des tests\n   */\n  async runDiagnostics() {\n    console.log('üîç Diagnostic de IPFS Desktop...');\n    const results = {\n      service: this.serviceName,\n      api: false,\n      gateway: false,\n      upload: false,\n      version: null,\n      errors: []\n    };\n    try {\n      // Test API\n      const version = await this.client.version();\n      results.api = true;\n      results.version = version.version;\n      console.log('‚úÖ API IPFS Desktop accessible');\n    } catch (error) {\n      results.errors.push(`API: ${error.message}`);\n      console.error('‚ùå API IPFS Desktop non accessible');\n    }\n    try {\n      // Test Gateway\n      const response = await fetch('http://localhost:8080/ipfs/QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn');\n      results.gateway = response.ok;\n      console.log(results.gateway ? '‚úÖ Gateway accessible' : '‚ùå Gateway non accessible');\n    } catch (error) {\n      results.errors.push(`Gateway: ${error.message}`);\n    }\n    try {\n      // Test Upload\n      const testData = `Test IPFS Desktop ${new Date().toISOString()}`;\n      const result = await this.client.add(testData);\n      results.upload = true;\n      console.log('‚úÖ Upload fonctionnel:', result.cid.toString());\n    } catch (error) {\n      results.errors.push(`Upload: ${error.message}`);\n    }\n    return results;\n  }\n}\n\n// Instance unique du service\nconst ipfsService = new IPFSService();\n\n// Exports pour compatibilit√©\nexport const uploadToIPFS = file => ipfsService.uploadFile(file);\nexport const getIPFSGatewayURL = hash => ipfsService.getGatewayURL(hash);\nexport default ipfsService;","map":{"version":3,"names":["create","IPFSService","constructor","client","isConnected","serviceName","initialize","host","port","protocol","version","console","log","error","message","checkConnection","uploadFile","file","Error","name","size","toFixed","arrayBuffer","fileContent","Uint8Array","result","add","path","content","pin","progress","bytes","percent","ipfsHash","cid","toString","getGatewayURL","setTimeout","isAccessible","verifyFileAccess","warn","code","includes","uploadJSON","data","jsonString","JSON","stringify","length","timeout","url","controller","AbortController","timeoutId","abort","response","fetch","method","signal","clearTimeout","ok","getFileInfo","stats","object","stat","hash","CumulativeSize","DataSize","links","NumLinks","accessible","service","getStatus","connected","type","apiPort","gatewayPort","apiUrl","gatewayUrl","webuiUrl","runDiagnostics","results","api","gateway","upload","errors","push","testData","Date","toISOString","ipfsService","uploadToIPFS","getIPFSGatewayURL"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["/**\n * Service IPFS pour IPFS Desktop\n * Optimis√© pour fonctionner avec votre configuration\n */\nimport { create } from 'ipfs-http-client';\n\nclass IPFSService {\n  constructor() {\n    this.client = null;\n    this.isConnected = false;\n    this.serviceName = 'IPFS Desktop';\n    this.initialize();\n  }\n\n  /**\n   * Initialise la connexion IPFS Desktop\n   */\n  async initialize() {\n    try {\n      // Configuration pour IPFS Desktop\n      this.client = create({\n        host: 'localhost',\n        port: 5001,\n        protocol: 'http'\n      });\n\n      // Tester la connexion\n      const version = await this.client.version();\n      this.isConnected = true;\n      \n      console.log('‚úÖ IPFS Desktop connect√© avec succ√®s!');\n      console.log('üì¶ Version IPFS:', version.version);\n      console.log('üîç Service:', this.serviceName);\n      \n    } catch (error) {\n      console.error('‚ùå Connexion √©chou√©e √† IPFS Desktop:', error.message);\n      console.log('üîß Solutions possibles:');\n      console.log('1. V√©rifiez que IPFS Desktop est d√©marr√©');\n      console.log('2. V√©rifiez la configuration CORS dans les param√®tres de IPFS Desktop');\n      console.log('3. Red√©marrez IPFS Desktop');\n      \n      this.isConnected = false;\n    }\n  }\n\n  /**\n   * V√©rifie la connexion √† IPFS Desktop\n   */\n  async checkConnection() {\n    try {\n      if (!this.client) {\n        await this.initialize();\n      }\n\n      const version = await this.client.version();\n      this.isConnected = true;\n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå IPFS Desktop non accessible:', error.message);\n      this.isConnected = false;\n      return false;\n    }\n  }\n\n  /**\n   * Upload un fichier sur IPFS Desktop\n   * @param {File} file - Le fichier √† uploader\n   * @returns {Promise<string>} - Le hash IPFS\n   */\n  async uploadFile(file) {\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n\n    console.log('üì§ Upload sur IPFS Desktop...');\n    console.log('üìÑ Fichier:', file.name);\n    console.log('üìä Taille:', (file.size / 1024 / 1024).toFixed(2), 'MB');\n\n    // V√©rifier la connexion\n    const isConnected = await this.checkConnection();\n    if (!isConnected) {\n      throw new Error('IPFS Desktop non disponible. V√©rifiez qu\\'il est bien d√©marr√©.');\n    }\n\n    try {\n      // Convertir le fichier en ArrayBuffer puis Uint8Array\n      const arrayBuffer = await file.arrayBuffer();\n      const fileContent = new Uint8Array(arrayBuffer);\n\n      console.log('‚è≥ Upload en cours...');\n\n      // Upload sur IPFS avec gestion du progr√®s\n      const result = await this.client.add({\n        path: file.name,\n        content: fileContent\n      }, {\n        pin: true, // √âpingler pour √©viter la suppression\n        progress: (bytes) => {\n          const percent = ((bytes / file.size) * 100).toFixed(1);\n          console.log(`üìä Progression: ${percent}% (${bytes}/${file.size} bytes)`);\n        }\n      });\n\n      const ipfsHash = result.cid.toString();\n      \n      console.log('‚úÖ Upload r√©ussi sur IPFS Desktop!');\n      console.log('üîó Hash IPFS:', ipfsHash);\n      console.log('üåê URL:', this.getGatewayURL(ipfsHash));\n\n      // V√©rifier que le fichier est accessible\n      setTimeout(async () => {\n        try {\n          const isAccessible = await this.verifyFileAccess(ipfsHash);\n          console.log(isAccessible ? '‚úÖ Fichier accessible via gateway' : '‚ö†Ô∏è Fichier pas encore accessible');\n        } catch (error) {\n          console.warn('‚ö†Ô∏è V√©rification d\\'acc√®s √©chou√©e:', error.message);\n        }\n      }, 1000);\n\n      return ipfsHash;\n\n    } catch (error) {\n      console.error('‚ùå Erreur upload sur IPFS Desktop:', error);\n      \n      // Messages d'erreur sp√©cifiques\n      if (error.code === 'ECONNREFUSED') {\n        throw new Error('IPFS Desktop non accessible. V√©rifiez qu\\'il est bien d√©marr√©.');\n      } else if (error.message.includes('fetch') || error.message.includes('CORS')) {\n        throw new Error('Erreur CORS. V√©rifiez la configuration CORS dans les param√®tres de IPFS Desktop.');\n      } else {\n        throw new Error(`Erreur upload: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Upload des donn√©es JSON sur IPFS Desktop\n   * @param {Object} data - Les donn√©es √† uploader\n   * @returns {Promise<string>} - Le hash IPFS\n   */\n  async uploadJSON(data) {\n    console.log('üì§ Upload JSON sur IPFS Desktop...');\n    console.log('üìÑ Donn√©es:', data);\n    \n    const isConnected = await this.checkConnection();\n    if (!isConnected) {\n      throw new Error('IPFS Desktop non disponible');\n    }\n\n    try {\n      const jsonString = JSON.stringify(data, null, 2);\n      console.log('üìù JSON format√©:', jsonString.length, 'caract√®res');\n\n      const result = await this.client.add(jsonString, { \n        pin: true,\n        timeout: 10000 // 10 secondes de timeout\n      });\n      \n      const ipfsHash = result.cid.toString();\n      console.log('‚úÖ JSON upload√© avec succ√®s!');\n      console.log('üîó Hash IPFS:', ipfsHash);\n      \n      return ipfsHash;\n\n    } catch (error) {\n      console.error('‚ùå Erreur upload JSON:', error);\n      throw new Error(`Erreur upload JSON sur IPFS Desktop: ${error.message}`);\n    }\n  }\n\n  /**\n   * V√©rifie qu'un fichier est accessible via la gateway\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {Promise<boolean>} - True si accessible\n   */\n  async verifyFileAccess(ipfsHash) {\n    try {\n      const url = this.getGatewayURL(ipfsHash);\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 5000);\n      \n      const response = await fetch(url, { \n        method: 'HEAD',\n        signal: controller.signal\n      });\n      \n      clearTimeout(timeoutId);\n      return response.ok;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * URL de la gateway IPFS pour IPFS Desktop\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {string} - L'URL compl√®te\n   */\n  getGatewayURL(ipfsHash) {\n    if (!ipfsHash) return '';\n    return `http://localhost:8080/ipfs/${ipfsHash}`;\n  }\n\n  /**\n   * Informations sur un fichier IPFS\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {Promise<Object>} - Les informations du fichier\n   */\n  async getFileInfo(ipfsHash) {\n    if (!this.isConnected) {\n      throw new Error('IPFS Desktop non connect√©');\n    }\n\n    try {\n      // Essayer de r√©cup√©rer les stats via l'API\n      const stats = await this.client.object.stat(ipfsHash);\n      \n      return {\n        hash: ipfsHash,\n        size: stats.CumulativeSize || stats.DataSize || 0,\n        links: stats.NumLinks || 0,\n        url: this.getGatewayURL(ipfsHash),\n        accessible: true,\n        service: this.serviceName\n      };\n    } catch (error) {\n      return {\n        hash: ipfsHash,\n        size: 0,\n        links: 0,\n        url: this.getGatewayURL(ipfsHash),\n        accessible: false,\n        error: error.message,\n        service: this.serviceName\n      };\n    }\n  }\n\n  /**\n   * Statut du service IPFS Desktop\n   * @returns {Object} - Informations d√©taill√©es\n   */\n  getStatus() {\n    return {\n      connected: this.isConnected,\n      service: this.serviceName,\n      type: 'Desktop',\n      host: 'localhost',\n      apiPort: 5001,\n      gatewayPort: 8080,\n      protocol: 'http',\n      apiUrl: 'http://localhost:5001',\n      gatewayUrl: 'http://localhost:8080',\n      webuiUrl: 'http://localhost:5001/webui'\n    };\n  }\n\n  /**\n   * Diagnostic complet de IPFS Desktop\n   * @returns {Promise<Object>} - R√©sultats des tests\n   */\n  async runDiagnostics() {\n    console.log('üîç Diagnostic de IPFS Desktop...');\n    const results = {\n      service: this.serviceName,\n      api: false,\n      gateway: false,\n      upload: false,\n      version: null,\n      errors: []\n    };\n\n    try {\n      // Test API\n      const version = await this.client.version();\n      results.api = true;\n      results.version = version.version;\n      console.log('‚úÖ API IPFS Desktop accessible');\n      \n    } catch (error) {\n      results.errors.push(`API: ${error.message}`);\n      console.error('‚ùå API IPFS Desktop non accessible');\n    }\n\n    try {\n      // Test Gateway\n      const response = await fetch('http://localhost:8080/ipfs/QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn');\n      results.gateway = response.ok;\n      console.log(results.gateway ? '‚úÖ Gateway accessible' : '‚ùå Gateway non accessible');\n      \n    } catch (error) {\n      results.errors.push(`Gateway: ${error.message}`);\n    }\n\n    try {\n      // Test Upload\n      const testData = `Test IPFS Desktop ${new Date().toISOString()}`;\n      const result = await this.client.add(testData);\n      results.upload = true;\n      console.log('‚úÖ Upload fonctionnel:', result.cid.toString());\n      \n    } catch (error) {\n      results.errors.push(`Upload: ${error.message}`);\n    }\n\n    return results;\n  }\n}\n\n// Instance unique du service\nconst ipfsService = new IPFSService();\n\n// Exports pour compatibilit√©\nexport const uploadToIPFS = (file) => ipfsService.uploadFile(file);\nexport const getIPFSGatewayURL = (hash) => ipfsService.getGatewayURL(hash);\n\nexport default ipfsService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}