{"ast":null,"code":"// # Multihash\nexport {};","map":{"version":3,"names":[],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@ipld\\dag-json\\node_modules\\multiformats\\src\\hashes\\interface.ts"],"sourcesContent":["// # Multihash\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\n// Note: In the current version there is no first class multihash\n// representation (plain Uint8Array is used instead) instead there seems to be\n// a bunch of places that parse it to extract (code, digest, size). By creating\n// this first class representation we avoid reparsing and things generally fit\n// really nicely.\nexport interface MultihashDigest<Code extends number = number> {\n  /**\n   * Code of the multihash\n   */\n  code: Code\n\n  /**\n   * Raw digest (without a hashing algorithm info)\n   */\n  digest: Uint8Array\n\n  /**\n   * byte length of the `this.digest`\n   */\n  size: number\n\n  /**\n   * Binary representation of this multihash digest.\n   */\n  bytes: Uint8Array\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport interface MultihashHasher<Code extends number = number> {\n  /**\n   * Takes binary `input` and returns it (multi) hash digest. Return value is\n   * either promise of a digest or a digest. This way general use can `await`\n   * while performance critical code may asses return value to decide whether\n   * await is needed.\n   */\n  digest(input: Uint8Array): Promise<MultihashDigest<Code>> | MultihashDigest<Code>\n\n  /**\n   * Name of the multihash\n   */\n  name: string\n\n  /**\n   * Code of the multihash\n   */\n  code: Code\n}\n\n/**\n * Sync variant of `MultihashHasher` that refines return type of the `digest`\n * to `MultihashDigest`. It is subtype of `MultihashHasher` so implementations\n * of this interface can be passed anywhere `MultihashHasher` is expected,\n * allowing consumer to either `await` or check the return type to decide\n * whether to await or proceed with return value.\n *\n * `SyncMultihashHasher` is useful in certain APIs where async hashing would be\n * impractical e.g. implementation of Hash Array Mapped Trie (HAMT).\n */\nexport interface SyncMultihashHasher<Code extends number = number> extends MultihashHasher<Code> {\n  digest(input: Uint8Array): MultihashDigest<Code>\n}\n"],"mappings":"AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}