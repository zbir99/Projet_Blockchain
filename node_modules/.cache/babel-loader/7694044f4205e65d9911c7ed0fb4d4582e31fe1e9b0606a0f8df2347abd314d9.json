{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * This module allows easy conversion of Multiaddrs to URLs.\n *\n * @example Converting multiaddrs to URLs\n *\n * ```js\n * import { multiaddrToUri } from '@multiformats/multiaddr-to-uri'\n *\n * console.log(multiaddrToUri('/dnsaddr/protocol.ai/https'))\n * // -> https://protocol.ai\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080'))\n * // -> http://127.0.0.1:8080\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080', { assumeHttp: false }))\n * // -> tcp://127.0.0.1:8080\n * ```\n *\n * Note:\n *\n * - When `/tcp` is the last (terminating) protocol HTTP is assumed by default (implicit `assumeHttp: true`)\n *   - this means produced URIs will start with `http://` instead of `tcp://`\n *   - passing `{ assumeHttp: false }` disables this behavior\n * - Might be lossy - e.g. a DNSv6 multiaddr\n * - Can throw if the passed multiaddr:\n *   - is not a valid multiaddr\n *   - is not supported as a URI e.g. circuit\n */\nimport { multiaddr, protocols } from '@multiformats/multiaddr';\nfunction extractSNI(ma) {\n  let sniProtoCode;\n  try {\n    sniProtoCode = protocols('sni').code;\n  } catch (e) {\n    // No SNI protocol in multiaddr\n    return null;\n  }\n  for (const [proto, value] of ma) {\n    if (proto === sniProtoCode && value !== undefined) {\n      return value;\n    }\n  }\n  return null;\n}\nfunction hasTLS(ma) {\n  return ma.some(([proto, _]) => proto === protocols('tls').code);\n}\nfunction interpretNext(headProtoCode, headProtoVal, restMa) {\n  const interpreter = interpreters[protocols(headProtoCode).name];\n  if (interpreter === undefined) {\n    throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`);\n  }\n  const restVal = interpreter(headProtoVal, restMa);\n  if (headProtoCode === protocols('ip6').code) {\n    return `[${restVal}]`;\n  }\n  return restVal;\n}\nconst interpreters = {\n  ip4: (value, restMa) => value,\n  ip6: (value, restMa) => {\n    if (restMa.length === 0) {\n      return value;\n    }\n    return `[${value}]`;\n  },\n  tcp: (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;\n  },\n  udp: (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`;\n  },\n  dnsaddr: (value, restMa) => value,\n  dns4: (value, restMa) => value,\n  dns6: (value, restMa) => value,\n  dns: (value, restMa) => value,\n  ipfs: (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`;\n  },\n  p2p: (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`;\n  },\n  http: (value, restMa) => {\n    const maHasTLS = hasTLS(restMa);\n    const sni = extractSNI(restMa);\n    if (maHasTLS && sni !== null) {\n      return `https://${sni}`;\n    }\n    const protocol = maHasTLS ? 'https://' : 'http://';\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '');\n    return `${protocol}${baseVal}`;\n  },\n  tls: (value, restMa) => {\n    // Noop, the parent context knows that it's tls. We don't need to do\n    // anything here\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n  },\n  sni: (value, restMa) => {\n    // Noop, the parent context uses the sni information, we don't need to do\n    // anything here\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n  },\n  https: (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '');\n    return `https://${baseVal}`;\n  },\n  ws: (value, restMa) => {\n    const maHasTLS = hasTLS(restMa);\n    const sni = extractSNI(restMa);\n    if (maHasTLS && sni !== null) {\n      return `wss://${sni}`;\n    }\n    const protocol = maHasTLS ? 'wss://' : 'ws://';\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n    // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '');\n    return `${protocol}${baseVal}`;\n  },\n  wss: (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa);\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '');\n    return `wss://${baseVal}`;\n  },\n  'p2p-websocket-star': (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`;\n  },\n  'p2p-webrtc-star': (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`;\n  },\n  'p2p-webrtc-direct': (value, restMa) => {\n    const tailProto = restMa.pop();\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr');\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`;\n  }\n};\nexport function multiaddrToUri(input, opts) {\n  const ma = multiaddr(input);\n  const parts = ma.stringTuples();\n  const head = parts.pop();\n  if (head === undefined) {\n    throw new Error('Unexpected end of multiaddr');\n  }\n  const protocol = protocols(head[0]);\n  const interpreter = interpreters[protocol.name];\n  if (interpreter == null) {\n    throw new Error(`No interpreter found for ${protocol.name}`);\n  }\n  let uri = interpreter(head[1] ?? '', parts);\n  if (opts?.assumeHttp !== false && head[0] === protocols('tcp').code) {\n    // If rightmost proto is tcp, we assume http here\n    uri = uri.replace('tcp://', 'http://');\n    if (head[1] === '443' || head[1] === '80') {\n      if (head[1] === '443') {\n        uri = uri.replace('http://', 'https://');\n      }\n      // Drop the port\n      uri = uri.substring(0, uri.lastIndexOf(':'));\n    }\n  }\n  return uri;\n}","map":{"version":3,"names":["multiaddr","protocols","extractSNI","ma","sniProtoCode","code","e","proto","value","undefined","hasTLS","some","_","interpretNext","headProtoCode","headProtoVal","restMa","interpreter","interpreters","name","Error","restVal","ip4","ip6","length","tcp","tailProto","pop","udp","dnsaddr","dns4","dns6","dns","ipfs","p2p","http","maHasTLS","sni","protocol","baseVal","replace","tls","https","ws","wss","p2p-websocket-star","p2p-webrtc-star","p2p-webrtc-direct","multiaddrToUri","input","opts","parts","stringTuples","head","uri","assumeHttp","substring","lastIndexOf"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@multiformats\\multiaddr-to-uri\\src\\index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * This module allows easy conversion of Multiaddrs to URLs.\n *\n * @example Converting multiaddrs to URLs\n *\n * ```js\n * import { multiaddrToUri } from '@multiformats/multiaddr-to-uri'\n *\n * console.log(multiaddrToUri('/dnsaddr/protocol.ai/https'))\n * // -> https://protocol.ai\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080'))\n * // -> http://127.0.0.1:8080\n *\n * console.log(multiaddrToUri('/ip4/127.0.0.1/tcp/8080', { assumeHttp: false }))\n * // -> tcp://127.0.0.1:8080\n * ```\n *\n * Note:\n *\n * - When `/tcp` is the last (terminating) protocol HTTP is assumed by default (implicit `assumeHttp: true`)\n *   - this means produced URIs will start with `http://` instead of `tcp://`\n *   - passing `{ assumeHttp: false }` disables this behavior\n * - Might be lossy - e.g. a DNSv6 multiaddr\n * - Can throw if the passed multiaddr:\n *   - is not a valid multiaddr\n *   - is not supported as a URI e.g. circuit\n */\n\nimport { multiaddr, protocols } from '@multiformats/multiaddr'\nimport type { Multiaddr, StringTuple } from '@multiformats/multiaddr'\n\nexport interface MultiaddrToUriOpts {\n  assumeHttp?: boolean\n}\n\ninterface Interpreter { (value: string, ma: StringTuple[]): string }\n\nfunction extractSNI (ma: StringTuple[]): string | null {\n  let sniProtoCode: number\n  try {\n    sniProtoCode = protocols('sni').code\n  } catch (e) {\n    // No SNI protocol in multiaddr\n    return null\n  }\n  for (const [proto, value] of ma) {\n    if (proto === sniProtoCode && value !== undefined) {\n      return value\n    }\n  }\n  return null\n}\n\nfunction hasTLS (ma: StringTuple[]): boolean {\n  return ma.some(([proto, _]) => proto === protocols('tls').code)\n}\n\nfunction interpretNext (headProtoCode: number, headProtoVal: string, restMa: StringTuple[]): string {\n  const interpreter = interpreters[protocols(headProtoCode).name]\n  if (interpreter === undefined) {\n    throw new Error(`Can't interpret protocol ${protocols(headProtoCode).name}`)\n  }\n  const restVal = interpreter(headProtoVal, restMa)\n  if (headProtoCode === protocols('ip6').code) {\n    return `[${restVal}]`\n  }\n  return restVal\n}\n\nconst interpreters: Record<string, Interpreter> = {\n  ip4: (value: string, restMa: StringTuple[]) => value,\n  ip6: (value: string, restMa: StringTuple[]) => {\n    if (restMa.length === 0) {\n      return value\n    }\n    return `[${value}]`\n  },\n  tcp: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `tcp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`\n  },\n  udp: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `udp://${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}:${value}`\n  },\n  dnsaddr: (value: string, restMa: StringTuple[]) => value,\n  dns4: (value: string, restMa: StringTuple[]) => value,\n  dns6: (value: string, restMa: StringTuple[]) => value,\n  dns: (value: string, restMa: StringTuple[]) => value,\n  ipfs: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/ipfs/${value}`\n  },\n  p2p: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p/${value}`\n  },\n  http: (value: string, restMa: StringTuple[]) => {\n    const maHasTLS = hasTLS(restMa)\n    const sni = extractSNI(restMa)\n    if (maHasTLS && sni !== null) {\n      return `https://${sni}`\n    }\n    const protocol = maHasTLS ? 'https://' : 'http://'\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  tls: (value: string, restMa: StringTuple[]) => {\n    // Noop, the parent context knows that it's tls. We don't need to do\n    // anything here\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n  },\n  sni: (value: string, restMa: StringTuple[]) => {\n    // Noop, the parent context uses the sni information, we don't need to do\n    // anything here\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n  },\n  https: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `https://${baseVal}`\n  },\n  ws: (value: string, restMa: StringTuple[]) => {\n    const maHasTLS = hasTLS(restMa)\n    const sni = extractSNI(restMa)\n    if (maHasTLS && sni !== null) {\n      return `wss://${sni}`\n    }\n    const protocol = maHasTLS ? 'wss://' : 'ws://'\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `${protocol}${baseVal}`\n  },\n  wss: (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    let baseVal = interpretNext(tailProto[0], tailProto[1] ?? '', restMa)\n    // We are reinterpreting the base as http, so we need to remove the tcp:// if it's there\n    baseVal = baseVal.replace('tcp://', '')\n    return `wss://${baseVal}`\n  },\n  'p2p-websocket-star': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-websocket-star`\n  },\n  'p2p-webrtc-star': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-star`\n  },\n  'p2p-webrtc-direct': (value: string, restMa: StringTuple[]) => {\n    const tailProto = restMa.pop()\n    if (tailProto === undefined) {\n      throw new Error('Unexpected end of multiaddr')\n    }\n    return `${interpretNext(tailProto[0], tailProto[1] ?? '', restMa)}/p2p-webrtc-direct`\n  }\n}\n\nexport function multiaddrToUri (input: Multiaddr | string | Uint8Array, opts?: MultiaddrToUriOpts): string {\n  const ma = multiaddr(input)\n  const parts = ma.stringTuples()\n  const head = parts.pop()\n  if (head === undefined) {\n    throw new Error('Unexpected end of multiaddr')\n  }\n\n  const protocol = protocols(head[0])\n  const interpreter = interpreters[protocol.name]\n\n  if (interpreter == null) {\n    throw new Error(`No interpreter found for ${protocol.name}`)\n  }\n\n  let uri = interpreter(head[1] ?? '', parts)\n  if (opts?.assumeHttp !== false && head[0] === protocols('tcp').code) {\n    // If rightmost proto is tcp, we assume http here\n    uri = uri.replace('tcp://', 'http://')\n    if (head[1] === '443' || head[1] === '80') {\n      if (head[1] === '443') {\n        uri = uri.replace('http://', 'https://')\n      }\n      // Drop the port\n      uri = uri.substring(0, uri.lastIndexOf(':'))\n    }\n  }\n\n  return uri\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}