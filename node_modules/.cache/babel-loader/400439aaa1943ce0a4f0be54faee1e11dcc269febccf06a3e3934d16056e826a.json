{"ast":null,"code":"// Base encoders / decoders just base encode / decode between binary and\n// textual representation. They are unaware of multibase.\nexport {};","map":{"version":3,"names":[],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@ipld\\dag-json\\node_modules\\multiformats\\src\\bases\\interface.ts"],"sourcesContent":["// Base encoders / decoders just base encode / decode between binary and\n// textual representation. They are unaware of multibase.\n\n/**\n * Base encoder just encodes bytes into base encoded string.\n */\nexport interface BaseEncoder {\n  /**\n   * Base encodes to a **plain** (and not a multibase) string. Unlike\n   * `encode` no multibase prefix is added.\n   */\n  baseEncode(bytes: Uint8Array): string\n}\n\n/**\n * Base decoder decodes encoded with matching base encoding into bytes.\n */\nexport interface BaseDecoder {\n  /**\n   * Decodes **plain** (and not a multibase) string. Unlike\n   * decode\n   */\n  baseDecode(text: string): Uint8Array\n}\n\n/**\n * Base codec is just dual of encoder and decoder.\n */\nexport interface BaseCodec {\n  encoder: BaseEncoder\n  decoder: BaseDecoder\n}\n\n/**\n * Multibase represents base encoded strings with a prefix first character\n * describing it's encoding.\n */\nexport type Multibase<Prefix extends string> =\n  | string\n  | string & { [0]: Prefix }\n\n/**\n * Multibase encoder for the specific base encoding encodes bytes into\n * multibase of that encoding.\n */\nexport interface MultibaseEncoder<Prefix extends string> {\n  /**\n   * Name of the encoding.\n   */\n  name: string\n  /**\n   * Prefix character for that base encoding.\n   */\n  prefix: Prefix\n  /**\n   * Encodes binary data into **multibase** string (which will have a\n   * prefix added).\n   */\n  encode(bytes: Uint8Array): Multibase<Prefix>\n}\n\n/**\n * Interface implemented by multibase decoder, that takes multibase strings\n * to bytes. It may support single encoding like base32 or multiple encodings\n * like base32, base58btc, base64. If passed multibase is incompatible it will\n * throw an exception.\n */\nexport interface MultibaseDecoder<Prefix extends string> {\n  /**\n   * Decodes **multibase** string (which must have a multibase prefix added).\n   * If prefix does not match\n   */\n  decode(multibase: Multibase<Prefix>): Uint8Array\n}\n\n/**\n * Dual of multibase encoder and decoder.\n */\nexport interface MultibaseCodec<Prefix extends string> {\n  name: string\n  prefix: Prefix\n  encoder: MultibaseEncoder<Prefix>\n  decoder: MultibaseDecoder<Prefix>\n}\n\nexport interface UnibaseDecoder<Prefix extends string> extends MultibaseDecoder<Prefix> {\n  // Reserve this property so it can be used to derive type.\n  readonly decoders?: null\n\n  readonly prefix: Prefix\n}\n\nexport interface CombobaseDecoder<Prefix extends string> extends MultibaseDecoder<Prefix> {\n  readonly decoders: Record<Prefix, UnibaseDecoder<Prefix>>\n}\n"],"mappings":"AAAA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}