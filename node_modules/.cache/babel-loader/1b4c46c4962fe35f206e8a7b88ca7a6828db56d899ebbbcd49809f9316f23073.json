{"ast":null,"code":"export {};","map":{"version":3,"names":[],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\multiformats\\src\\block\\interface.ts"],"sourcesContent":["import type { CID } from '../cid.js'\nimport type { Link, Version } from '../link/interface.js'\n\n/**\n * A byte-encoded representation of some type of `Data`.\n *\n * A `ByteView` is essentially a `Uint8Array` that's been \"tagged\" with\n * a `Data` type parameter indicating the type of encoded data.\n *\n * For example, a `ByteView<{ hello: \"world\" }>` is a `Uint8Array` containing a\n * binary representation of a `{hello: \"world\"}`.\n */\nexport interface ByteView<Data> extends Uint8Array, Phantom<Data> {}\n\n/**\n * Similar to ByteView but extends ArrayBuffer.\n */\nexport interface ArrayBufferView<Data> extends ArrayBuffer, Phantom<Data> {}\n\ndeclare const Marker: unique symbol\n\n/**\n * A utility type to retain an unused type parameter `T`.\n * Similar to [phantom type parameters in Rust](https://doc.rust-lang.org/rust-by-example/generics/phantom.html).\n *\n * Capturing unused type parameters allows us to define \"nominal types,\" which\n * TypeScript does not natively support. Nominal types in turn allow us to capture\n * semantics not represented in the actual type structure, without requiring us to define\n * new classes or pay additional runtime costs.\n *\n * For a concrete example, see {@link ByteView}, which extends the `Uint8Array` type to capture\n * type information about the structure of the data encoded into the array.\n */\nexport interface Phantom<T> {\n  // This field can not be represented because field name is non-existent\n  // unique symbol. But given that field is optional any object will valid\n  // type constraint.\n  [Marker]?: T\n}\n\n/**\n * Represents an IPLD block (including its CID) that can be decoded to data of\n * type `T`.\n *\n * @template T - Logical type of the data encoded in the block\n * @template C - multicodec code corresponding to codec used to encode the block\n * @template A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport interface Block<\n  T = unknown,\n  C extends number = number,\n  A extends number = number,\n  V extends Version = 1\n> {\n  bytes: ByteView<T>\n  cid: Link<T, C, A, V>\n}\n\nexport type BlockCursorView<T = unknown> =\n  | { value: T, remaining?: undefined }\n  | { value: CID, remaining: string }\n\nexport interface BlockView<\n  T = unknown,\n  C extends number = number,\n  A extends number = number,\n  V extends Version = 1\n> extends Block<T, C, A, V> {\n  cid: CID<T, C, A, V>\n  value: T\n\n  links(): Iterable<[string, CID]>\n  tree(): Iterable<string>\n  get(path: string): BlockCursorView<unknown>\n}\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}