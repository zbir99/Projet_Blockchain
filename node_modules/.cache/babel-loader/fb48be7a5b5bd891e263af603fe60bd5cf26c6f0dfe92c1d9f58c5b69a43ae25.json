{"ast":null,"code":"import { assert, isHexString } from \"../utils/index.js\";\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if (isHexString(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\n// @TODO: refactor this\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber {\n  #provider;\n  #poller;\n  #interval;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  constructor(provider) {\n    this.#provider = provider;\n    this.#poller = null;\n    this.#interval = 4000;\n    this.#blockNumber = -2;\n  }\n  get pollingInterval() {\n    return this.#interval;\n  }\n  set pollingInterval(value) {\n    this.#interval = value;\n  }\n  async #poll() {\n    const blockNumber = await this.#provider.getBlockNumber();\n    if (this.#blockNumber === -2) {\n      this.#blockNumber = blockNumber;\n      return;\n    }\n    // @TODO: Put a cap on the maximum number of events per loop?\n    if (blockNumber !== this.#blockNumber) {\n      for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n        // We have been stopped\n        if (this.#poller == null) {\n          return;\n        }\n        await this.#provider.emit(\"block\", b);\n      }\n      this.#blockNumber = blockNumber;\n    }\n    // We have been stopped\n    if (this.#poller == null) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n  }\n  start() {\n    if (this.#poller) {\n      throw new Error(\"subscriber already running\");\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    this.#poll();\n  }\n  stop() {\n    if (!this.#poller) {\n      throw new Error(\"subscriber not running\");\n    }\n    this.#provider._clearTimeout(this.#poller);\n    this.#poller = null;\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber {\n  #provider;\n  #poll;\n  constructor(provider) {\n    this.#provider = provider;\n    this.#poll = blockNumber => {\n      this._poll(blockNumber, this.#provider);\n    };\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    this.#poll(-2);\n    this.#provider.on(\"block\", this.#poll);\n  }\n  stop() {\n    this.#provider.off(\"block\", this.#poll);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n  #filter;\n  constructor(provider, filter) {\n    super(provider);\n    this.#filter = copy(filter);\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(this.#filter);\n  }\n}\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n  #hash;\n  constructor(provider, hash) {\n    super(provider);\n    this.#hash = hash;\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(this.#hash);\n    if (tx) {\n      provider.emit(this.#hash, tx);\n    }\n  }\n}\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber {\n  #provider;\n  #filter;\n  #poller;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  constructor(provider, filter) {\n    this.#provider = provider;\n    this.#filter = copy(filter);\n    this.#poller = this.#poll.bind(this);\n    this.#blockNumber = -2;\n  }\n  async #poll(blockNumber) {\n    // The initial block hasn't been determined yet\n    if (this.#blockNumber === -2) {\n      return;\n    }\n    const filter = copy(this.#filter);\n    filter.fromBlock = this.#blockNumber + 1;\n    filter.toBlock = blockNumber;\n    const logs = await this.#provider.getLogs(filter);\n    // No logs could just mean the node has not indexed them yet,\n    // so we keep a sliding window of 60 blocks to keep scanning\n    if (logs.length === 0) {\n      if (this.#blockNumber < blockNumber - 60) {\n        this.#blockNumber = blockNumber - 60;\n      }\n      return;\n    }\n    this.#blockNumber = blockNumber;\n    for (const log of logs) {\n      this.#provider.emit(this.#filter, log);\n    }\n  }\n  start() {\n    if (this.#blockNumber === -2) {\n      this.#provider.getBlockNumber().then(blockNumber => {\n        this.#blockNumber = blockNumber;\n      });\n    }\n    this.#provider.on(\"block\", this.#poller);\n  }\n  stop() {\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}","map":{"version":3,"names":["assert","isHexString","copy","obj","JSON","parse","stringify","getPollingSubscriber","provider","event","PollingBlockSubscriber","PollingTransactionSubscriber","operation","info","poller","interval","blockNumber","constructor","pollingInterval","value","poll","#poll","getBlockNumber","b","emit","_setTimeout","bind","start","Error","stop","_clearTimeout","pause","dropWhilePaused","resume","OnBlockSubscriber","_poll","on","off","PollingOrphanSubscriber","filter","console","log","hash","tx","getTransactionReceipt","PollingEventSubscriber","fromBlock","toBlock","logs","getLogs","length","then"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\ethers\\src.ts\\providers\\subscriber-polling.ts"],"sourcesContent":["import { assert, isHexString } from \"../utils/index.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { EventFilter, OrphanFilter, ProviderEvent } from \"./provider.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider: AbstractProvider, event: ProviderEvent): Subscriber {\n    if (event === \"block\") { return new PollingBlockSubscriber(provider); }\n    if (isHexString(event, 32)) { return new PollingTransactionSubscriber(provider, event); }\n\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n\n// @TODO: refactor this\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poller: null | number;\n\n    #interval: number;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n\n        this.#blockNumber = -2;\n    }\n\n    get pollingInterval(): number { return this.#interval; }\n    set pollingInterval(value: number) { this.#interval = value; }\n\n    async #poll(): Promise<void> {\n        const blockNumber = await this.#provider.getBlockNumber();\n        if (this.#blockNumber === -2) {\n            this.#blockNumber = blockNumber;\n            return;\n        }\n\n        // @TODO: Put a cap on the maximum number of events per loop?\n\n        if (blockNumber !== this.#blockNumber) {\n            for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                // We have been stopped\n                if (this.#poller == null) { return; }\n\n                await this.#provider.emit(\"block\", b);\n            }\n\n            this.#blockNumber = blockNumber;\n        }\n\n        // We have been stopped\n        if (this.#poller == null) { return; }\n\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n\n    start(): void {\n        if (this.#poller) { throw new Error(\"subscriber already running\"); }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n\n    stop(): void {\n        if (!this.#poller) { throw new Error(\"subscriber not running\"); }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poll: (b: number) => void;\n\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#poll = (blockNumber: number) => {\n            this._poll(blockNumber, this.#provider);\n        }\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n\n    start(): void {\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n\n    stop(): void {\n        this.#provider.off(\"block\", this.#poll);\n    }\n\n    pause(dropWhilePaused?: boolean): void { this.stop(); }\n    resume(): void { this.start(); }\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter: OrphanFilter;\n\n    constructor(provider: AbstractProvider, filter: OrphanFilter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash: string;\n\n    constructor(provider: AbstractProvider, hash: string) {\n        super(provider);\n        this.#hash = hash;\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) { provider.emit(this.#hash, tx); }\n    }\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #filter: EventFilter;\n    #poller: (b: number) => void;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    constructor(provider: AbstractProvider, filter: EventFilter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#blockNumber = -2;\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) { return; }\n\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n\n        this.#blockNumber = blockNumber;\n\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n        }\n    }\n\n    start(): void {\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n\n    stop(): void {\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,WAAW,QAAQ,mBAAmB;AAKvD,SAASC,IAAIA,CAACC,GAAQ;EAClB,OAAOC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAACH,GAAG,CAAC,CAAC;AAC1C;AAEA;;;;;AAKA,OAAM,SAAUI,oBAAoBA,CAACC,QAA0B,EAAEC,KAAoB;EACjF,IAAIA,KAAK,KAAK,OAAO,EAAE;IAAE,OAAO,IAAIC,sBAAsB,CAACF,QAAQ,CAAC;;EACpE,IAAIP,WAAW,CAACQ,KAAK,EAAE,EAAE,CAAC,EAAE;IAAE,OAAO,IAAIE,4BAA4B,CAACH,QAAQ,EAAEC,KAAK,CAAC;;EAEtFT,MAAM,CAAC,KAAK,EAAE,2BAA2B,EAAE,uBAAuB,EAAE;IAChEY,SAAS,EAAE,sBAAsB;IAAEC,IAAI,EAAE;MAAEJ;IAAK;GACnD,CAAC;AACN;AAEA;AAEA;;;;;AAKA,OAAM,MAAOC,sBAAsB;EAC/B,CAAAF,QAAS;EACT,CAAAM,MAAO;EAEP,CAAAC,QAAS;EAET;EACA;EACA,CAAAC,WAAY;EAEZC,YAAYT,QAA0B;IAClC,IAAI,CAAC,CAAAA,QAAS,GAAGA,QAAQ;IACzB,IAAI,CAAC,CAAAM,MAAO,GAAG,IAAI;IACnB,IAAI,CAAC,CAAAC,QAAS,GAAG,IAAI;IAErB,IAAI,CAAC,CAAAC,WAAY,GAAG,CAAC,CAAC;EAC1B;EAEA,IAAIE,eAAeA,CAAA;IAAa,OAAO,IAAI,CAAC,CAAAH,QAAS;EAAE;EACvD,IAAIG,eAAeA,CAACC,KAAa;IAAI,IAAI,CAAC,CAAAJ,QAAS,GAAGI,KAAK;EAAE;EAE7D,MAAM,CAAAC,IAAKC,CAAA;IACP,MAAML,WAAW,GAAG,MAAM,IAAI,CAAC,CAAAR,QAAS,CAACc,cAAc,EAAE;IACzD,IAAI,IAAI,CAAC,CAAAN,WAAY,KAAK,CAAC,CAAC,EAAE;MAC1B,IAAI,CAAC,CAAAA,WAAY,GAAGA,WAAW;MAC/B;;IAGJ;IAEA,IAAIA,WAAW,KAAK,IAAI,CAAC,CAAAA,WAAY,EAAE;MACnC,KAAK,IAAIO,CAAC,GAAG,IAAI,CAAC,CAAAP,WAAY,GAAG,CAAC,EAAEO,CAAC,IAAIP,WAAW,EAAEO,CAAC,EAAE,EAAE;QACvD;QACA,IAAI,IAAI,CAAC,CAAAT,MAAO,IAAI,IAAI,EAAE;UAAE;;QAE5B,MAAM,IAAI,CAAC,CAAAN,QAAS,CAACgB,IAAI,CAAC,OAAO,EAAED,CAAC,CAAC;;MAGzC,IAAI,CAAC,CAAAP,WAAY,GAAGA,WAAW;;IAGnC;IACA,IAAI,IAAI,CAAC,CAAAF,MAAO,IAAI,IAAI,EAAE;MAAE;;IAE5B,IAAI,CAAC,CAAAA,MAAO,GAAG,IAAI,CAAC,CAAAN,QAAS,CAACiB,WAAW,CAAC,IAAI,CAAC,CAAAL,IAAK,CAACM,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAAX,QAAS,CAAC;EACpF;EAEAY,KAAKA,CAAA;IACD,IAAI,IAAI,CAAC,CAAAb,MAAO,EAAE;MAAE,MAAM,IAAIc,KAAK,CAAC,4BAA4B,CAAC;;IACjE,IAAI,CAAC,CAAAd,MAAO,GAAG,IAAI,CAAC,CAAAN,QAAS,CAACiB,WAAW,CAAC,IAAI,CAAC,CAAAL,IAAK,CAACM,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,CAAAX,QAAS,CAAC;IAChF,IAAI,CAAC,CAAAK,IAAK,EAAE;EAChB;EAEAS,IAAIA,CAAA;IACA,IAAI,CAAC,IAAI,CAAC,CAAAf,MAAO,EAAE;MAAE,MAAM,IAAIc,KAAK,CAAC,wBAAwB,CAAC;;IAC9D,IAAI,CAAC,CAAApB,QAAS,CAACsB,aAAa,CAAC,IAAI,CAAC,CAAAhB,MAAO,CAAC;IAC1C,IAAI,CAAC,CAAAA,MAAO,GAAG,IAAI;EACvB;EAEAiB,KAAKA,CAACC,eAAyB;IAC3B,IAAI,CAACH,IAAI,EAAE;IACX,IAAIG,eAAe,EAAE;MAAE,IAAI,CAAC,CAAAhB,WAAY,GAAG,CAAC,CAAC;;EACjD;EAEAiB,MAAMA,CAAA;IACF,IAAI,CAACN,KAAK,EAAE;EAChB;;AAGJ;;;;;AAKA,OAAM,MAAOO,iBAAiB;EAC1B,CAAA1B,QAAS;EACT,CAAAY,IAAK;EAELH,YAAYT,QAA0B;IAClC,IAAI,CAAC,CAAAA,QAAS,GAAGA,QAAQ;IACzB,IAAI,CAAC,CAAAY,IAAK,GAAIJ,WAAmB,IAAI;MACjC,IAAI,CAACmB,KAAK,CAACnB,WAAW,EAAE,IAAI,CAAC,CAAAR,QAAS,CAAC;IAC3C,CAAC;EACL;EAEA,MAAM2B,KAAKA,CAACnB,WAAmB,EAAER,QAA0B;IACvD,MAAM,IAAIoB,KAAK,CAAC,gCAAgC,CAAC;EACrD;EAEAD,KAAKA,CAAA;IACD,IAAI,CAAC,CAAAP,IAAK,CAAC,CAAC,CAAC,CAAC;IACd,IAAI,CAAC,CAAAZ,QAAS,CAAC4B,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,CAAAhB,IAAK,CAAC;EAC1C;EAEAS,IAAIA,CAAA;IACA,IAAI,CAAC,CAAArB,QAAS,CAAC6B,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAAjB,IAAK,CAAC;EAC3C;EAEAW,KAAKA,CAACC,eAAyB;IAAU,IAAI,CAACH,IAAI,EAAE;EAAE;EACtDI,MAAMA,CAAA;IAAW,IAAI,CAACN,KAAK,EAAE;EAAE;;AAGnC;;;;;AAKA,OAAM,MAAOW,uBAAwB,SAAQJ,iBAAiB;EAC1D,CAAAK,MAAO;EAEPtB,YAAYT,QAA0B,EAAE+B,MAAoB;IACxD,KAAK,CAAC/B,QAAQ,CAAC;IACf,IAAI,CAAC,CAAA+B,MAAO,GAAGrC,IAAI,CAACqC,MAAM,CAAC;EAC/B;EAEA,MAAMJ,KAAKA,CAACnB,WAAmB,EAAER,QAA0B;IACvD,MAAM,IAAIoB,KAAK,CAAC,OAAO,CAAC;IACxBY,OAAO,CAACC,GAAG,CAAC,IAAI,CAAC,CAAAF,MAAO,CAAC;EAC7B;;AAGJ;;;;;AAKA,OAAM,MAAO5B,4BAA6B,SAAQuB,iBAAiB;EAC/D,CAAAQ,IAAK;EAELzB,YAAYT,QAA0B,EAAEkC,IAAY;IAChD,KAAK,CAAClC,QAAQ,CAAC;IACf,IAAI,CAAC,CAAAkC,IAAK,GAAGA,IAAI;EACrB;EAEA,MAAMP,KAAKA,CAACnB,WAAmB,EAAER,QAA0B;IACvD,MAAMmC,EAAE,GAAG,MAAMnC,QAAQ,CAACoC,qBAAqB,CAAC,IAAI,CAAC,CAAAF,IAAK,CAAC;IAC3D,IAAIC,EAAE,EAAE;MAAEnC,QAAQ,CAACgB,IAAI,CAAC,IAAI,CAAC,CAAAkB,IAAK,EAAEC,EAAE,CAAC;;EAC3C;;AAGJ;;;;;AAKA,OAAM,MAAOE,sBAAsB;EAC/B,CAAArC,QAAS;EACT,CAAA+B,MAAO;EACP,CAAAzB,MAAO;EAEP;EACA;EACA,CAAAE,WAAY;EAEZC,YAAYT,QAA0B,EAAE+B,MAAmB;IACvD,IAAI,CAAC,CAAA/B,QAAS,GAAGA,QAAQ;IACzB,IAAI,CAAC,CAAA+B,MAAO,GAAGrC,IAAI,CAACqC,MAAM,CAAC;IAC3B,IAAI,CAAC,CAAAzB,MAAO,GAAG,IAAI,CAAC,CAAAM,IAAK,CAACM,IAAI,CAAC,IAAI,CAAC;IACpC,IAAI,CAAC,CAAAV,WAAY,GAAG,CAAC,CAAC;EAC1B;EAEA,MAAM,CAAAI,IAAKC,CAACL,WAAmB;IAC3B;IACA,IAAI,IAAI,CAAC,CAAAA,WAAY,KAAK,CAAC,CAAC,EAAE;MAAE;;IAEhC,MAAMuB,MAAM,GAAGrC,IAAI,CAAC,IAAI,CAAC,CAAAqC,MAAO,CAAC;IACjCA,MAAM,CAACO,SAAS,GAAG,IAAI,CAAC,CAAA9B,WAAY,GAAG,CAAC;IACxCuB,MAAM,CAACQ,OAAO,GAAG/B,WAAW;IAC5B,MAAMgC,IAAI,GAAG,MAAM,IAAI,CAAC,CAAAxC,QAAS,CAACyC,OAAO,CAACV,MAAM,CAAC;IAEjD;IACA;IACA,IAAIS,IAAI,CAACE,MAAM,KAAK,CAAC,EAAE;MACnB,IAAI,IAAI,CAAC,CAAAlC,WAAY,GAAGA,WAAW,GAAG,EAAE,EAAE;QACtC,IAAI,CAAC,CAAAA,WAAY,GAAGA,WAAW,GAAG,EAAE;;MAExC;;IAGJ,IAAI,CAAC,CAAAA,WAAY,GAAGA,WAAW;IAE/B,KAAK,MAAMyB,GAAG,IAAIO,IAAI,EAAE;MACpB,IAAI,CAAC,CAAAxC,QAAS,CAACgB,IAAI,CAAC,IAAI,CAAC,CAAAe,MAAO,EAAEE,GAAG,CAAC;;EAE9C;EAEAd,KAAKA,CAAA;IACD,IAAI,IAAI,CAAC,CAAAX,WAAY,KAAK,CAAC,CAAC,EAAE;MAC1B,IAAI,CAAC,CAAAR,QAAS,CAACc,cAAc,EAAE,CAAC6B,IAAI,CAAEnC,WAAW,IAAI;QACjD,IAAI,CAAC,CAAAA,WAAY,GAAGA,WAAW;MACnC,CAAC,CAAC;;IAEN,IAAI,CAAC,CAAAR,QAAS,CAAC4B,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,CAAAtB,MAAO,CAAC;EAC5C;EAEAe,IAAIA,CAAA;IACA,IAAI,CAAC,CAAArB,QAAS,CAAC6B,GAAG,CAAC,OAAO,EAAE,IAAI,CAAC,CAAAvB,MAAO,CAAC;EAC7C;EAEAiB,KAAKA,CAACC,eAAyB;IAC3B,IAAI,CAACH,IAAI,EAAE;IACX,IAAIG,eAAe,EAAE;MAAE,IAAI,CAAC,CAAAhB,WAAY,GAAG,CAAC,CAAC;;EACjD;EAEAiB,MAAMA,CAAA;IACF,IAAI,CAACN,KAAK,EAAE;EAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}