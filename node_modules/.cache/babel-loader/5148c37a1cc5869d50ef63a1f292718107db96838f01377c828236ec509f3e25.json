{"ast":null,"code":"import { create } from 'ipfs-http-client';\n\n// Configuration du client IPFS pour se connecter au daemon IPFS local\n// avec gestion des erreurs CORS\nlet ipfs;\n\n/**\n * Génère un hash aléatoire pour simuler un CID IPFS\n * @returns {string} - Hash simulé\n */\nconst generateMockHash = () => {\n  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  let hash = 'Qm';\n  for (let i = 0; i < 44; i++) {\n    hash += characters.charAt(Math.floor(Math.random() * characters.length));\n  }\n  return hash;\n};\n\n/**\n * Télécharge un fichier sur le stockage simulé IPFS\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS simulé du fichier\n */\nexport const uploadToIPFS = async file => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n\n    // Générer un hash simulé\n    const mockHash = generateMockHash();\n\n    // Stocker le fichier en mémoire (pour la simulation)\n    const fileURL = URL.createObjectURL(file);\n    mockIPFSStorage.set(mockHash, {\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      url: fileURL\n    });\n    console.log(`Fichier \"${file.name}\" téléchargé avec succès (simulation IPFS)`);\n    console.log(`Hash simulé: ${mockHash}`);\n\n    // Simuler un délai réseau pour rendre l'expérience plus réaliste\n    await new Promise(resolve => setTimeout(resolve, 500));\n    return mockHash;\n    try {\n      // Essai avec ipfs-http-client\n      const result = await ipfs.add(new Uint8Array(fileBuffer));\n      return result.path;\n    } catch (ipfsError) {\n      console.warn('Erreur avec ipfs-http-client, tentative avec fetch direct:', ipfsError);\n\n      // Méthode alternative avec fetch\n      const formData = new FormData();\n      formData.append('file', file);\n      const response = await fetch('http://localhost:5001/api/v0/add', {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`Erreur HTTP: ${response.status}`);\n      }\n      const data = await response.json();\n      return data.Hash;\n    }\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS:', error);\n    throw error;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur la passerelle IPFS locale\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = ipfsHash => {\n  if (!ipfsHash) return '';\n  return `http://localhost:8080/ipfs/${ipfsHash}`;\n};\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};","map":{"version":3,"names":["create","ipfs","generateMockHash","characters","hash","i","charAt","Math","floor","random","length","uploadToIPFS","file","Error","mockHash","fileURL","URL","createObjectURL","mockIPFSStorage","set","name","type","size","url","console","log","Promise","resolve","setTimeout","result","add","Uint8Array","fileBuffer","path","ipfsError","warn","formData","FormData","append","response","fetch","method","body","headers","ok","status","data","json","Hash","error","getIPFSGatewayURL","ipfsHash"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["import { create } from 'ipfs-http-client';\n\n// Configuration du client IPFS pour se connecter au daemon IPFS local\n// avec gestion des erreurs CORS\nlet ipfs;\n\n/**\n * Génère un hash aléatoire pour simuler un CID IPFS\n * @returns {string} - Hash simulé\n */\nconst generateMockHash = () => {\n  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  let hash = 'Qm';\n  for (let i = 0; i < 44; i++) {\n    hash += characters.charAt(Math.floor(Math.random() * characters.length));\n  }\n  return hash;\n};\n\n/**\n * Télécharge un fichier sur le stockage simulé IPFS\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS simulé du fichier\n */\nexport const uploadToIPFS = async (file) => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    \n    // Générer un hash simulé\n    const mockHash = generateMockHash();\n    \n    // Stocker le fichier en mémoire (pour la simulation)\n    const fileURL = URL.createObjectURL(file);\n    mockIPFSStorage.set(mockHash, {\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      url: fileURL\n    });\n    \n    console.log(`Fichier \"${file.name}\" téléchargé avec succès (simulation IPFS)`); \n    console.log(`Hash simulé: ${mockHash}`);\n    \n    // Simuler un délai réseau pour rendre l'expérience plus réaliste\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    return mockHash;\n    try {\n      // Essai avec ipfs-http-client\n      const result = await ipfs.add(new Uint8Array(fileBuffer));\n      return result.path;\n    } catch (ipfsError) {\n      console.warn('Erreur avec ipfs-http-client, tentative avec fetch direct:', ipfsError);\n      \n      // Méthode alternative avec fetch\n      const formData = new FormData();\n      formData.append('file', file);\n      \n      const response = await fetch('http://localhost:5001/api/v0/add', {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Erreur HTTP: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      return data.Hash;\n    }\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS:', error);\n    throw error;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur la passerelle IPFS locale\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = (ipfsHash) => {\n  if (!ipfsHash) return '';\n  return `http://localhost:8080/ipfs/${ipfsHash}`;\n};\n\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,kBAAkB;;AAEzC;AACA;AACA,IAAIC,IAAI;;AAER;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAC7B,MAAMC,UAAU,GAAG,sCAAsC;EACzD,IAAIC,IAAI,GAAG,IAAI;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;IAC3BD,IAAI,IAAID,UAAU,CAACG,MAAM,CAACC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGN,UAAU,CAACO,MAAM,CAAC,CAAC;EAC1E;EACA,OAAON,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMO,YAAY,GAAG,MAAOC,IAAI,IAAK;EAC1C,IAAI;IACF;IACA,IAAI,CAACA,IAAI,EAAE;MACT,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;IACzC;;IAEA;IACA,MAAMC,QAAQ,GAAGZ,gBAAgB,CAAC,CAAC;;IAEnC;IACA,MAAMa,OAAO,GAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC;IACzCM,eAAe,CAACC,GAAG,CAACL,QAAQ,EAAE;MAC5BM,IAAI,EAAER,IAAI,CAACQ,IAAI;MACfC,IAAI,EAAET,IAAI,CAACS,IAAI;MACfC,IAAI,EAAEV,IAAI,CAACU,IAAI;MACfC,GAAG,EAAER;IACP,CAAC,CAAC;IAEFS,OAAO,CAACC,GAAG,CAAC,YAAYb,IAAI,CAACQ,IAAI,4CAA4C,CAAC;IAC9EI,OAAO,CAACC,GAAG,CAAC,gBAAgBX,QAAQ,EAAE,CAAC;;IAEvC;IACA,MAAM,IAAIY,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;IAEtD,OAAOb,QAAQ;IACf,IAAI;MACF;MACA,MAAMe,MAAM,GAAG,MAAM5B,IAAI,CAAC6B,GAAG,CAAC,IAAIC,UAAU,CAACC,UAAU,CAAC,CAAC;MACzD,OAAOH,MAAM,CAACI,IAAI;IACpB,CAAC,CAAC,OAAOC,SAAS,EAAE;MAClBV,OAAO,CAACW,IAAI,CAAC,4DAA4D,EAAED,SAAS,CAAC;;MAErF;MACA,MAAME,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;MAC/BD,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAE1B,IAAI,CAAC;MAE7B,MAAM2B,QAAQ,GAAG,MAAMC,KAAK,CAAC,kCAAkC,EAAE;QAC/DC,MAAM,EAAE,MAAM;QACdC,IAAI,EAAEN,QAAQ;QACdO,OAAO,EAAE;UACP,QAAQ,EAAE;QACZ;MACF,CAAC,CAAC;MAEF,IAAI,CAACJ,QAAQ,CAACK,EAAE,EAAE;QAChB,MAAM,IAAI/B,KAAK,CAAC,gBAAgB0B,QAAQ,CAACM,MAAM,EAAE,CAAC;MACpD;MAEA,MAAMC,IAAI,GAAG,MAAMP,QAAQ,CAACQ,IAAI,CAAC,CAAC;MAClC,OAAOD,IAAI,CAACE,IAAI;IAClB;EACF,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdzB,OAAO,CAACyB,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;IAC/D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,GAAIC,QAAQ,IAAK;EAC7C,IAAI,CAACA,QAAQ,EAAE,OAAO,EAAE;EACxB,OAAO,8BAA8BA,QAAQ,EAAE;AACjD,CAAC;AAED,eAAe;EACbxC,YAAY;EACZuC;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}