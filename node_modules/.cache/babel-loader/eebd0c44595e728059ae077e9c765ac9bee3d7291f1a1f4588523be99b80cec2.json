{"ast":null,"code":"import { connect } from \"net\";\nimport { SocketProvider } from \"./provider-socket.js\";\n// @TODO: Is this sufficient? Is this robust? Will newlines occur between\n// all payloads and only between payloads?\nfunction splitBuffer(data) {\n  const messages = [];\n  let lastStart = 0;\n  while (true) {\n    const nl = data.indexOf(10, lastStart);\n    if (nl === -1) {\n      break;\n    }\n    messages.push(data.subarray(lastStart, nl).toString().trim());\n    lastStart = nl + 1;\n  }\n  return {\n    messages,\n    remaining: data.subarray(lastStart)\n  };\n}\nexport class IpcSocketProvider extends SocketProvider {\n  #socket;\n  get socket() {\n    return this.#socket;\n  }\n  constructor(path, network) {\n    super(network);\n    this.#socket = connect(path);\n    this.socket.on(\"ready\", async () => {\n      try {\n        await this._start();\n      } catch (error) {\n        console.log(\"failed to start IpcSocketProvider\", error);\n        // @TODO: Now what? Restart?\n      }\n    });\n    let response = Buffer.alloc(0);\n    this.socket.on(\"data\", data => {\n      response = Buffer.concat([response, data]);\n      const {\n        messages,\n        remaining\n      } = splitBuffer(response);\n      messages.forEach(message => {\n        this._processMessage(message);\n      });\n      response = remaining;\n    });\n    this.socket.on(\"end\", () => {\n      this.emit(\"close\");\n      this.socket.destroy();\n      this.socket.end();\n    });\n  }\n  destroy() {\n    this.socket.destroy();\n    this.socket.end();\n    super.destroy();\n  }\n  async _write(message) {\n    console.log(\">>>\", message);\n    this.socket.write(message);\n  }\n}","map":{"version":3,"names":["connect","SocketProvider","splitBuffer","data","messages","lastStart","nl","indexOf","push","subarray","toString","trim","remaining","IpcSocketProvider","socket","constructor","path","network","on","_start","error","console","log","response","Buffer","alloc","concat","forEach","message","_processMessage","emit","destroy","end","_write","write"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\ethers\\src.ts\\providers\\provider-ipcsocket.ts"],"sourcesContent":["\nimport { connect } from \"net\";\nimport { SocketProvider } from \"./provider-socket.js\";\n\nimport type { Socket } from \"net\";\nimport type { Networkish } from \"./network.js\";\n\n\n// @TODO: Is this sufficient? Is this robust? Will newlines occur between\n// all payloads and only between payloads?\nfunction splitBuffer(data: Buffer): { messages: Array<string>, remaining: Buffer } {\n    const messages: Array<string> = [ ];\n\n    let lastStart = 0;\n    while (true) {\n        const nl = data.indexOf(10, lastStart);\n        if (nl === -1) { break; }\n        messages.push(data.subarray(lastStart, nl).toString().trim());\n        lastStart = nl + 1;\n    }\n\n    return { messages, remaining: data.subarray(lastStart) };\n}\n\nexport class IpcSocketProvider extends SocketProvider {\n    #socket: Socket;\n    get socket(): Socket { return this.#socket; }\n\n    constructor(path: string, network?: Networkish) {\n        super(network);\n        this.#socket = connect(path);\n\n        this.socket.on(\"ready\", async () => {\n            try {\n                await this._start();\n            } catch (error) {\n                console.log(\"failed to start IpcSocketProvider\", error);\n                // @TODO: Now what? Restart?\n            }\n        });\n\n        let response = Buffer.alloc(0);\n        this.socket.on(\"data\", (data) => {\n            response = Buffer.concat([ response, data ]);\n            const { messages, remaining } = splitBuffer(response);\n            messages.forEach((message) => {\n                this._processMessage(message);\n            });\n            response = remaining;\n        });\n\n        this.socket.on(\"end\", () => {\n            this.emit(\"close\");\n            this.socket.destroy();\n            this.socket.end();\n        });\n    }\n\n    destroy(): void {\n        this.socket.destroy();\n        this.socket.end();\n\n        super.destroy();\n    }\n\n    async _write(message: string): Promise<void> {\n        console.log(\">>>\", message);\n        this.socket.write(message);\n    }\n}\n"],"mappings":"AACA,SAASA,OAAO,QAAQ,KAAK;AAC7B,SAASC,cAAc,QAAQ,sBAAsB;AAMrD;AACA;AACA,SAASC,WAAWA,CAACC,IAAY;EAC7B,MAAMC,QAAQ,GAAkB,EAAG;EAEnC,IAAIC,SAAS,GAAG,CAAC;EACjB,OAAO,IAAI,EAAE;IACT,MAAMC,EAAE,GAAGH,IAAI,CAACI,OAAO,CAAC,EAAE,EAAEF,SAAS,CAAC;IACtC,IAAIC,EAAE,KAAK,CAAC,CAAC,EAAE;MAAE;;IACjBF,QAAQ,CAACI,IAAI,CAACL,IAAI,CAACM,QAAQ,CAACJ,SAAS,EAAEC,EAAE,CAAC,CAACI,QAAQ,EAAE,CAACC,IAAI,EAAE,CAAC;IAC7DN,SAAS,GAAGC,EAAE,GAAG,CAAC;;EAGtB,OAAO;IAAEF,QAAQ;IAAEQ,SAAS,EAAET,IAAI,CAACM,QAAQ,CAACJ,SAAS;EAAC,CAAE;AAC5D;AAEA,OAAM,MAAOQ,iBAAkB,SAAQZ,cAAc;EACjD,CAAAa,MAAO;EACP,IAAIA,MAAMA,CAAA;IAAa,OAAO,IAAI,CAAC,CAAAA,MAAO;EAAE;EAE5CC,YAAYC,IAAY,EAAEC,OAAoB;IAC1C,KAAK,CAACA,OAAO,CAAC;IACd,IAAI,CAAC,CAAAH,MAAO,GAAGd,OAAO,CAACgB,IAAI,CAAC;IAE5B,IAAI,CAACF,MAAM,CAACI,EAAE,CAAC,OAAO,EAAE,YAAW;MAC/B,IAAI;QACA,MAAM,IAAI,CAACC,MAAM,EAAE;OACtB,CAAC,OAAOC,KAAK,EAAE;QACZC,OAAO,CAACC,GAAG,CAAC,mCAAmC,EAAEF,KAAK,CAAC;QACvD;;IAER,CAAC,CAAC;IAEF,IAAIG,QAAQ,GAAGC,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IAC9B,IAAI,CAACX,MAAM,CAACI,EAAE,CAAC,MAAM,EAAGf,IAAI,IAAI;MAC5BoB,QAAQ,GAAGC,MAAM,CAACE,MAAM,CAAC,CAAEH,QAAQ,EAAEpB,IAAI,CAAE,CAAC;MAC5C,MAAM;QAAEC,QAAQ;QAAEQ;MAAS,CAAE,GAAGV,WAAW,CAACqB,QAAQ,CAAC;MACrDnB,QAAQ,CAACuB,OAAO,CAAEC,OAAO,IAAI;QACzB,IAAI,CAACC,eAAe,CAACD,OAAO,CAAC;MACjC,CAAC,CAAC;MACFL,QAAQ,GAAGX,SAAS;IACxB,CAAC,CAAC;IAEF,IAAI,CAACE,MAAM,CAACI,EAAE,CAAC,KAAK,EAAE,MAAK;MACvB,IAAI,CAACY,IAAI,CAAC,OAAO,CAAC;MAClB,IAAI,CAAChB,MAAM,CAACiB,OAAO,EAAE;MACrB,IAAI,CAACjB,MAAM,CAACkB,GAAG,EAAE;IACrB,CAAC,CAAC;EACN;EAEAD,OAAOA,CAAA;IACH,IAAI,CAACjB,MAAM,CAACiB,OAAO,EAAE;IACrB,IAAI,CAACjB,MAAM,CAACkB,GAAG,EAAE;IAEjB,KAAK,CAACD,OAAO,EAAE;EACnB;EAEA,MAAME,MAAMA,CAACL,OAAe;IACxBP,OAAO,CAACC,GAAG,CAAC,KAAK,EAAEM,OAAO,CAAC;IAC3B,IAAI,CAACd,MAAM,CAACoB,KAAK,CAACN,OAAO,CAAC;EAC9B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}