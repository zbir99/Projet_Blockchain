{"ast":null,"code":"import { base32 } from './bases/base32.js';\nimport { base36 } from './bases/base36.js';\nimport { base58btc } from './bases/base58.js';\nimport { coerce } from './bytes.js';\nimport * as Digest from './hashes/digest.js';\nimport * as varint from './varint.js';\n// This way TS will also expose all the types from module\nexport * from './link/interface.js';\nexport function format(link, base) {\n  const {\n    bytes,\n    version\n  } = link;\n  switch (version) {\n    case 0:\n      return toStringV0(bytes, baseCache(link), base ?? base58btc.encoder);\n    default:\n      return toStringV1(bytes, baseCache(link), base ?? base32.encoder);\n  }\n}\nexport function toJSON(link) {\n  return {\n    '/': format(link)\n  };\n}\nexport function fromJSON(json) {\n  return CID.parse(json['/']);\n}\nconst cache = new WeakMap();\nfunction baseCache(cid) {\n  const baseCache = cache.get(cid);\n  if (baseCache == null) {\n    const baseCache = new Map();\n    cache.set(cid, baseCache);\n    return baseCache;\n  }\n  return baseCache;\n}\nexport class CID {\n  code;\n  version;\n  multihash;\n  bytes;\n  '/';\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor(version, code, multihash, bytes) {\n    this.code = code;\n    this.version = version;\n    this.multihash = multihash;\n    this.bytes = bytes;\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes;\n  }\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID() {\n    return this;\n  }\n  // ArrayBufferView\n  get byteOffset() {\n    return this.bytes.byteOffset;\n  }\n  // ArrayBufferView\n  get byteLength() {\n    return this.bytes.byteLength;\n  }\n  toV0() {\n    switch (this.version) {\n      case 0:\n        {\n          return this;\n        }\n      case 1:\n        {\n          const {\n            code,\n            multihash\n          } = this;\n          if (code !== DAG_PB_CODE) {\n            throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n          }\n          // sha2-256\n          if (multihash.code !== SHA_256_CODE) {\n            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n          }\n          return CID.createV0(multihash);\n        }\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);\n        }\n    }\n  }\n  toV1() {\n    switch (this.version) {\n      case 0:\n        {\n          const {\n            code,\n            digest\n          } = this.multihash;\n          const multihash = Digest.create(code, digest);\n          return CID.createV1(this.code, multihash);\n        }\n      case 1:\n        {\n          return this;\n        }\n      default:\n        {\n          throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);\n        }\n    }\n  }\n  equals(other) {\n    return CID.equals(this, other);\n  }\n  static equals(self, other) {\n    const unknown = other;\n    return unknown != null && self.code === unknown.code && self.version === unknown.version && Digest.equals(self.multihash, unknown.multihash);\n  }\n  toString(base) {\n    return format(this, base);\n  }\n  toJSON() {\n    return {\n      '/': format(this)\n    };\n  }\n  link() {\n    return this;\n  }\n  [Symbol.toStringTag] = 'CID';\n  // Legacy\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return `CID(${this.toString()})`;\n  }\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID(input) {\n    if (input == null) {\n      return null;\n    }\n    const value = input;\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value;\n    } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const {\n        version,\n        code,\n        multihash,\n        bytes\n      } = value;\n      return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const {\n        version,\n        multihash,\n        code\n      } = value;\n      const digest = Digest.decode(multihash);\n      return CID.create(version, code, digest);\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null;\n    }\n  }\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create(version, code, digest) {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported');\n    }\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest');\n    }\n    switch (version) {\n      case 0:\n        {\n          if (code !== DAG_PB_CODE) {\n            throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);\n          } else {\n            return new CID(version, code, digest, digest.bytes);\n          }\n        }\n      case 1:\n        {\n          const bytes = encodeCID(version, code, digest.bytes);\n          return new CID(version, code, digest, bytes);\n        }\n      default:\n        {\n          throw new Error('Invalid version');\n        }\n    }\n  }\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0(digest) {\n    return CID.create(0, DAG_PB_CODE, digest);\n  }\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1(code, digest) {\n    return CID.create(1, code, digest);\n  }\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode(bytes) {\n    const [cid, remainder] = CID.decodeFirst(bytes);\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length');\n    }\n    return cid;\n  }\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst(bytes) {\n    const specs = CID.inspectBytes(bytes);\n    const prefixSize = specs.size - specs.multihashSize;\n    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length');\n    }\n    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);\n    const digest = new Digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);\n    const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);\n    return [cid, bytes.subarray(specs.size)];\n  }\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes(initialBytes) {\n    let offset = 0;\n    const next = () => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset));\n      offset += length;\n      return i;\n    };\n    let version = next();\n    let codec = DAG_PB_CODE;\n    if (version === 18) {\n      // CIDv0\n      version = 0;\n      offset = 0;\n    } else {\n      codec = next();\n    }\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`);\n    }\n    const prefixSize = offset;\n    const multihashCode = next(); // multihash code\n    const digestSize = next(); // multihash length\n    const size = offset + digestSize;\n    const multihashSize = size - prefixSize;\n    return {\n      version,\n      codec,\n      multihashCode,\n      digestSize,\n      multihashSize,\n      size\n    };\n  }\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse(source, base) {\n    const [prefix, bytes] = parseCIDtoBytes(source, base);\n    const cid = CID.decode(bytes);\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix');\n    }\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source);\n    return cid;\n  }\n}\nfunction parseCIDtoBytes(source, base) {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q':\n      {\n        const decoder = base ?? base58btc;\n        return [base58btc.prefix, decoder.decode(`${base58btc.prefix}${source}`)];\n      }\n    case base58btc.prefix:\n      {\n        const decoder = base ?? base58btc;\n        return [base58btc.prefix, decoder.decode(source)];\n      }\n    case base32.prefix:\n      {\n        const decoder = base ?? base32;\n        return [base32.prefix, decoder.decode(source)];\n      }\n    case base36.prefix:\n      {\n        const decoder = base ?? base36;\n        return [base36.prefix, decoder.decode(source)];\n      }\n    default:\n      {\n        if (base == null) {\n          throw Error('To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided');\n        }\n        return [source[0], base.decode(source)];\n      }\n  }\n}\nfunction toStringV0(bytes, cache, base) {\n  const {\n    prefix\n  } = base;\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`);\n  }\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n}\nfunction toStringV1(bytes, cache, base) {\n  const {\n    prefix\n  } = base;\n  const cid = cache.get(prefix);\n  if (cid == null) {\n    const cid = base.encode(bytes);\n    cache.set(prefix, cid);\n    return cid;\n  } else {\n    return cid;\n  }\n}\nconst DAG_PB_CODE = 0x70;\nconst SHA_256_CODE = 0x12;\nfunction encodeCID(version, code, multihash) {\n  const codeOffset = varint.encodingLength(version);\n  const hashOffset = codeOffset + varint.encodingLength(code);\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength);\n  varint.encodeTo(version, bytes, 0);\n  varint.encodeTo(code, bytes, codeOffset);\n  bytes.set(multihash, hashOffset);\n  return bytes;\n}\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID');","map":{"version":3,"names":["base32","base36","base58btc","coerce","Digest","varint","format","link","base","bytes","version","toStringV0","baseCache","encoder","toStringV1","toJSON","fromJSON","json","CID","parse","cache","WeakMap","cid","get","Map","set","code","multihash","constructor","asCID","byteOffset","byteLength","toV0","DAG_PB_CODE","Error","SHA_256_CODE","createV0","toV1","digest","create","createV1","equals","other","self","unknown","toString","Symbol","toStringTag","for","input","value","encodeCID","cidSymbol","decode","Uint8Array","remainder","decodeFirst","length","specs","inspectBytes","prefixSize","size","multihashSize","multihashBytes","subarray","digestBytes","digestSize","multihashCode","codec","initialBytes","offset","next","i","RangeError","source","prefix","parseCIDtoBytes","decoder","name","encode","slice","codeOffset","encodingLength","hashOffset","encodeTo"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\multiformats\\src\\cid.ts"],"sourcesContent":["import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}