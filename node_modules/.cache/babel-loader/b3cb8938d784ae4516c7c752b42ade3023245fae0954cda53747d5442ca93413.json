{"ast":null,"code":"import { symbol } from '@libp2p/interface-peer-id';\nimport { CodeError } from '@libp2p/interfaces/errors';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { identity } from 'multiformats/hashes/identity';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals';\nconst inspect = Symbol.for('nodejs.util.inspect.custom');\nconst baseDecoder = Object.values(bases).map(codec => codec.decoder)\n// @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n.reduce((acc, curr) => acc.or(curr), bases.identity.decoder);\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72;\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;\nclass PeerIdImpl {\n  type;\n  multihash;\n  privateKey;\n  publicKey;\n  string;\n  constructor(init) {\n    this.type = init.type;\n    this.multihash = init.multihash;\n    this.privateKey = init.privateKey;\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    });\n  }\n  get [Symbol.toStringTag]() {\n    return `PeerId(${this.toString()})`;\n  }\n  [symbol] = true;\n  toString() {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1);\n    }\n    return this.string;\n  }\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toCID() {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);\n  }\n  toBytes() {\n    return this.multihash.bytes;\n  }\n  /**\n   * Returns Multiaddr as a JSON string\n   */\n  toJSON() {\n    return this.toString();\n  }\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n  equals(id) {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id);\n    } else if (typeof id === 'string') {\n      return peerIdFromString(id).equals(this);\n    } else if (id?.multihash?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes);\n    } else {\n      throw new Error('not valid Id');\n    }\n  }\n  /**\n   * Returns PeerId as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { peerIdFromString } from '@libp2p/peer-id'\n   *\n   * console.info(peerIdFromString('QmFoo'))\n   * // 'PeerId(QmFoo)'\n   * ```\n   */\n  [inspect]() {\n    return `PeerId(${this.toString()})`;\n  }\n}\nclass RSAPeerIdImpl extends PeerIdImpl {\n  type = 'RSA';\n  publicKey;\n  constructor(init) {\n    super({\n      ...init,\n      type: 'RSA'\n    });\n    this.publicKey = init.publicKey;\n  }\n}\nclass Ed25519PeerIdImpl extends PeerIdImpl {\n  type = 'Ed25519';\n  publicKey;\n  constructor(init) {\n    super({\n      ...init,\n      type: 'Ed25519'\n    });\n    this.publicKey = init.multihash.digest;\n  }\n}\nclass Secp256k1PeerIdImpl extends PeerIdImpl {\n  type = 'secp256k1';\n  publicKey;\n  constructor(init) {\n    super({\n      ...init,\n      type: 'secp256k1'\n    });\n    this.publicKey = init.multihash.digest;\n  }\n}\nexport function createPeerId(init) {\n  if (init.type === 'RSA') {\n    return new RSAPeerIdImpl(init);\n  }\n  if (init.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(init);\n  }\n  if (init.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(init);\n  }\n  throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromPeerId(other) {\n  if (other.type === 'RSA') {\n    return new RSAPeerIdImpl(other);\n  }\n  if (other.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(other);\n  }\n  if (other.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(other);\n  }\n  throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS');\n}\nexport function peerIdFromString(str, decoder) {\n  decoder = decoder ?? baseDecoder;\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    const multihash = Digest.decode(base58btc.decode(`z${str}`));\n    if (str.startsWith('12D')) {\n      return new Ed25519PeerIdImpl({\n        multihash\n      });\n    } else if (str.startsWith('16U')) {\n      return new Secp256k1PeerIdImpl({\n        multihash\n      });\n    } else {\n      return new RSAPeerIdImpl({\n        multihash\n      });\n    }\n  }\n  return peerIdFromBytes(baseDecoder.decode(str));\n}\nexport function peerIdFromBytes(buf) {\n  try {\n    const multihash = Digest.decode(buf);\n    if (multihash.code === identity.code) {\n      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({\n          multihash\n        });\n      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({\n          multihash\n        });\n      }\n    }\n    if (multihash.code === sha256.code) {\n      return new RSAPeerIdImpl({\n        multihash\n      });\n    }\n  } catch {\n    return peerIdFromCID(CID.decode(buf));\n  }\n  throw new Error('Supplied PeerID CID is invalid');\n}\nexport function peerIdFromCID(cid) {\n  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {\n    throw new Error('Supplied PeerID CID is invalid');\n  }\n  const multihash = cid.multihash;\n  if (multihash.code === sha256.code) {\n    return new RSAPeerIdImpl({\n      multihash: cid.multihash\n    });\n  } else if (multihash.code === identity.code) {\n    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n      return new Ed25519PeerIdImpl({\n        multihash: cid.multihash\n      });\n    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n      return new Secp256k1PeerIdImpl({\n        multihash: cid.multihash\n      });\n    }\n  }\n  throw new Error('Supplied PeerID CID is invalid');\n}\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys(publicKey, privateKey) {\n  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n    return new Ed25519PeerIdImpl({\n      multihash: Digest.create(identity.code, publicKey),\n      privateKey\n    });\n  }\n  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n    return new Secp256k1PeerIdImpl({\n      multihash: Digest.create(identity.code, publicKey),\n      privateKey\n    });\n  }\n  return new RSAPeerIdImpl({\n    multihash: await sha256.digest(publicKey),\n    publicKey,\n    privateKey\n  });\n}","map":{"version":3,"names":["symbol","CodeError","base58btc","bases","CID","Digest","identity","sha256","equals","uint8ArrayEquals","inspect","Symbol","for","baseDecoder","Object","values","map","codec","decoder","reduce","acc","curr","or","LIBP2P_KEY_CODE","MARSHALLED_ED225519_PUBLIC_KEY_LENGTH","MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH","PeerIdImpl","type","multihash","privateKey","publicKey","string","constructor","init","defineProperty","enumerable","writable","toStringTag","toString","encode","bytes","slice","toCID","createV1","toBytes","toJSON","id","Uint8Array","peerIdFromString","Error","RSAPeerIdImpl","Ed25519PeerIdImpl","digest","Secp256k1PeerIdImpl","createPeerId","peerIdFromPeerId","other","str","charAt","decode","startsWith","peerIdFromBytes","buf","code","length","peerIdFromCID","cid","version","peerIdFromKeys","create"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@libp2p\\peer-id\\src\\index.ts"],"sourcesContent":["import { type Ed25519PeerId, type PeerIdType, type RSAPeerId, type Secp256k1PeerId, symbol, type PeerId } from '@libp2p/interface-peer-id'\nimport { CodeError } from '@libp2p/interfaces/errors'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport type { MultibaseDecoder } from 'multiformats/bases/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\n\nconst baseDecoder = Object\n  .values(bases)\n  .map(codec => codec.decoder)\n  // @ts-expect-error https://github.com/multiformats/js-multiformats/issues/141\n  .reduce((acc, curr) => acc.or(curr), bases.identity.decoder)\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\n\nconst MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36\nconst MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37\n\ninterface PeerIdInit {\n  type: PeerIdType\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\ninterface RSAPeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n  publicKey?: Uint8Array\n}\n\ninterface Ed25519PeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\ninterface Secp256k1PeerIdInit {\n  multihash: MultihashDigest\n  privateKey?: Uint8Array\n}\n\nclass PeerIdImpl {\n  public type: PeerIdType\n  public readonly multihash: MultihashDigest\n  public readonly privateKey?: Uint8Array\n  public readonly publicKey?: Uint8Array\n  private string?: string\n\n  constructor (init: PeerIdInit) {\n    this.type = init.type\n    this.multihash = init.multihash\n    this.privateKey = init.privateKey\n\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    })\n  }\n\n  get [Symbol.toStringTag] (): string {\n    return `PeerId(${this.toString()})`\n  }\n\n  readonly [symbol] = true\n\n  toString (): string {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1)\n    }\n\n    return this.string\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toCID (): CID {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash)\n  }\n\n  toBytes (): Uint8Array {\n    return this.multihash.bytes\n  }\n\n  /**\n   * Returns Multiaddr as a JSON string\n   */\n  toJSON (): string {\n    return this.toString()\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n  equals (id: PeerId | Uint8Array | string): boolean {\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id)\n    } else if (typeof id === 'string') {\n      return peerIdFromString(id).equals(this as PeerId)\n    } else if (id?.multihash?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.multihash.bytes)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Returns PeerId as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```js\n   * import { peerIdFromString } from '@libp2p/peer-id'\n   *\n   * console.info(peerIdFromString('QmFoo'))\n   * // 'PeerId(QmFoo)'\n   * ```\n   */\n  [inspect] (): string {\n    return `PeerId(${this.toString()})`\n  }\n}\n\nclass RSAPeerIdImpl extends PeerIdImpl implements RSAPeerId {\n  public readonly type = 'RSA'\n  public readonly publicKey?: Uint8Array\n\n  constructor (init: RSAPeerIdInit) {\n    super({ ...init, type: 'RSA' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nclass Ed25519PeerIdImpl extends PeerIdImpl implements Ed25519PeerId {\n  public readonly type = 'Ed25519'\n  public readonly publicKey: Uint8Array\n\n  constructor (init: Ed25519PeerIdInit) {\n    super({ ...init, type: 'Ed25519' })\n\n    this.publicKey = init.multihash.digest\n  }\n}\n\nclass Secp256k1PeerIdImpl extends PeerIdImpl implements Secp256k1PeerId {\n  public readonly type = 'secp256k1'\n  public readonly publicKey: Uint8Array\n\n  constructor (init: Secp256k1PeerIdInit) {\n    super({ ...init, type: 'secp256k1' })\n\n    this.publicKey = init.multihash.digest\n  }\n}\n\nexport function createPeerId (init: PeerIdInit): PeerId {\n  if (init.type === 'RSA') {\n    return new RSAPeerIdImpl(init)\n  }\n\n  if (init.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(init)\n  }\n\n  if (init.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(init)\n  }\n\n  throw new CodeError('Type must be \"RSA\", \"Ed25519\" or \"secp256k1\"', 'ERR_INVALID_PARAMETERS')\n}\n\nexport function peerIdFromPeerId (other: any): PeerId {\n  if (other.type === 'RSA') {\n    return new RSAPeerIdImpl(other)\n  }\n\n  if (other.type === 'Ed25519') {\n    return new Ed25519PeerIdImpl(other)\n  }\n\n  if (other.type === 'secp256k1') {\n    return new Secp256k1PeerIdImpl(other)\n  }\n\n  throw new CodeError('Not a PeerId', 'ERR_INVALID_PARAMETERS')\n}\n\nexport function peerIdFromString (str: string, decoder?: MultibaseDecoder<any>): PeerId {\n  decoder = decoder ?? baseDecoder\n\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    const multihash = Digest.decode(base58btc.decode(`z${str}`))\n\n    if (str.startsWith('12D')) {\n      return new Ed25519PeerIdImpl({ multihash })\n    } else if (str.startsWith('16U')) {\n      return new Secp256k1PeerIdImpl({ multihash })\n    } else {\n      return new RSAPeerIdImpl({ multihash })\n    }\n  }\n\n  return peerIdFromBytes(baseDecoder.decode(str))\n}\n\nexport function peerIdFromBytes (buf: Uint8Array): PeerId {\n  try {\n    const multihash = Digest.decode(buf)\n\n    if (multihash.code === identity.code) {\n      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n        return new Ed25519PeerIdImpl({ multihash })\n      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n        return new Secp256k1PeerIdImpl({ multihash })\n      }\n    }\n\n    if (multihash.code === sha256.code) {\n      return new RSAPeerIdImpl({ multihash })\n    }\n  } catch {\n    return peerIdFromCID(CID.decode(buf))\n  }\n\n  throw new Error('Supplied PeerID CID is invalid')\n}\n\nexport function peerIdFromCID (cid: CID): PeerId {\n  if (cid == null || cid.multihash == null || cid.version == null || (cid.version === 1 && cid.code !== LIBP2P_KEY_CODE)) {\n    throw new Error('Supplied PeerID CID is invalid')\n  }\n\n  const multihash = cid.multihash\n\n  if (multihash.code === sha256.code) {\n    return new RSAPeerIdImpl({ multihash: cid.multihash })\n  } else if (multihash.code === identity.code) {\n    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n      return new Ed25519PeerIdImpl({ multihash: cid.multihash })\n    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n      return new Secp256k1PeerIdImpl({ multihash: cid.multihash })\n    }\n  }\n\n  throw new Error('Supplied PeerID CID is invalid')\n}\n\n/**\n * @param publicKey - A marshalled public key\n * @param privateKey - A marshalled private key\n */\nexport async function peerIdFromKeys (publicKey: Uint8Array, privateKey?: Uint8Array): Promise<PeerId> {\n  if (publicKey.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {\n    return new Ed25519PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey })\n  }\n\n  if (publicKey.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {\n    return new Secp256k1PeerIdImpl({ multihash: Digest.create(identity.code, publicKey), privateKey })\n  }\n\n  return new RSAPeerIdImpl({ multihash: await sha256.digest(publicKey), publicKey, privateKey })\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}