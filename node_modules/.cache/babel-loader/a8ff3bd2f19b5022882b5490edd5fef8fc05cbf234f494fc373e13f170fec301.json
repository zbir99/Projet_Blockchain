{"ast":null,"code":"/**\n * Utilitaire pour interagir avec IPFS local via une passerelle publique\n * Cette approche contourne les problèmes CORS en utilisant une passerelle publique\n */\n\n/**\n * Télécharge un fichier sur IPFS en utilisant une passerelle publique\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS du fichier téléchargé\n */\nexport const uploadToIPFS = async file => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    console.log('Début du téléchargement sur IPFS...');\n\n    // Créer un objet FormData pour l'envoi du fichier\n    const formData = new FormData();\n    formData.append('file', file);\n\n    // Utiliser une passerelle IPFS publique qui accepte les uploads\n    // Note: Dans un environnement de production, il faudrait utiliser un service IPFS dédié\n    // avec authentification comme Infura ou Pinata\n    const response = await fetch('https://ipfs.infura.io:5001/api/v0/add', {\n      method: 'POST',\n      body: formData,\n      headers: {\n        // Ajoutez ici vos clés d'API si nécessaire pour un service comme Infura ou Pinata\n        // 'Authorization': 'Basic ' + btoa('YOUR_PROJECT_ID:YOUR_PROJECT_SECRET')\n      }\n    });\n    if (!response.ok) {\n      // Si l'upload via passerelle publique échoue, générer un hash temporaire\n      // et stocker le fichier localement (comme solution de secours)\n      console.warn('Impossible d\\'utiliser la passerelle IPFS publique, utilisation du stockage local temporaire');\n\n      // Générer un hash temporaire\n      const tempHash = 'Qm' + Array.from(crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');\n\n      // Stocker le fichier dans le stockage local (sessionStorage)\n      const fileReader = new FileReader();\n      fileReader.readAsDataURL(file);\n      const fileDataUrl = await new Promise((resolve, reject) => {\n        fileReader.onload = () => resolve(fileReader.result);\n        fileReader.onerror = reject;\n      });\n\n      // Stocker le fichier dans sessionStorage\n      sessionStorage.setItem(`ipfs-file-${tempHash}`, fileDataUrl);\n      sessionStorage.setItem(`ipfs-file-name-${tempHash}`, file.name);\n      console.log(`Fichier \"${file.name}\" stocké temporairement avec le hash: ${tempHash}`);\n      return tempHash;\n    }\n    const data = await response.json();\n    console.log(`Fichier \"${file.name}\" téléchargé sur IPFS avec succès`);\n    console.log(`Hash IPFS: ${data.Hash}`);\n    return data.Hash;\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS:', error);\n\n    // Solution de secours en cas d'erreur\n    console.warn('Utilisation du stockage local temporaire suite à une erreur');\n\n    // Générer un hash temporaire\n    const tempHash = 'Qm' + Array.from(crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');\n\n    // Stocker le fichier dans le stockage local (sessionStorage)\n    const fileReader = new FileReader();\n    fileReader.readAsDataURL(file);\n    const fileDataUrl = await new Promise((resolve, reject) => {\n      fileReader.onload = () => resolve(fileReader.result);\n      fileReader.onerror = reject;\n    });\n\n    // Stocker le fichier dans sessionStorage\n    sessionStorage.setItem(`ipfs-file-${tempHash}`, fileDataUrl);\n    sessionStorage.setItem(`ipfs-file-name-${tempHash}`, file.name);\n    console.log(`Fichier \"${file.name}\" stocké temporairement avec le hash: ${tempHash}`);\n    return tempHash;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur IPFS\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = ipfsHash => {\n  if (!ipfsHash) return '';\n\n  // Vérifier si le hash est dans notre stockage local temporaire\n  if (sessionStorage.getItem(`ipfs-file-${ipfsHash}`)) {\n    // Créer un blob URL à partir des données stockées\n    const dataUrl = sessionStorage.getItem(`ipfs-file-${ipfsHash}`);\n    return dataUrl;\n  }\n\n  // Essayer plusieurs passerelles IPFS publiques (dans l'ordre de préférence)\n  // Note: Nous utilisons d'abord Cloudflare qui est plus fiable que ipfs.io\n  return `https://cloudflare-ipfs.com/ipfs/${ipfsHash}`;\n\n  // Autres passerelles alternatives si nécessaire :\n  // return `https://gateway.pinata.cloud/ipfs/${ipfsHash}`;\n  // return `https://ipfs.io/ipfs/${ipfsHash}`;\n};\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};","map":{"version":3,"names":["uploadToIPFS","file","Error","console","log","formData","FormData","append","response","fetch","method","body","headers","ok","warn","tempHash","Array","from","crypto","getRandomValues","Uint8Array","map","b","toString","padStart","join","fileReader","FileReader","readAsDataURL","fileDataUrl","Promise","resolve","reject","onload","result","onerror","sessionStorage","setItem","name","data","json","Hash","error","getIPFSGatewayURL","ipfsHash","getItem","dataUrl"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["/**\n * Utilitaire pour interagir avec IPFS local via une passerelle publique\n * Cette approche contourne les problèmes CORS en utilisant une passerelle publique\n */\n\n/**\n * Télécharge un fichier sur IPFS en utilisant une passerelle publique\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS du fichier téléchargé\n */\nexport const uploadToIPFS = async (file) => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    \n    console.log('Début du téléchargement sur IPFS...');\n    \n    // Créer un objet FormData pour l'envoi du fichier\n    const formData = new FormData();\n    formData.append('file', file);\n    \n    // Utiliser une passerelle IPFS publique qui accepte les uploads\n    // Note: Dans un environnement de production, il faudrait utiliser un service IPFS dédié\n    // avec authentification comme Infura ou Pinata\n    const response = await fetch('https://ipfs.infura.io:5001/api/v0/add', {\n      method: 'POST',\n      body: formData,\n      headers: {\n        // Ajoutez ici vos clés d'API si nécessaire pour un service comme Infura ou Pinata\n        // 'Authorization': 'Basic ' + btoa('YOUR_PROJECT_ID:YOUR_PROJECT_SECRET')\n      }\n    });\n    \n    if (!response.ok) {\n      // Si l'upload via passerelle publique échoue, générer un hash temporaire\n      // et stocker le fichier localement (comme solution de secours)\n      console.warn('Impossible d\\'utiliser la passerelle IPFS publique, utilisation du stockage local temporaire');\n      \n      // Générer un hash temporaire\n      const tempHash = 'Qm' + Array.from(crypto.getRandomValues(new Uint8Array(32)))\n        .map(b => b.toString(16).padStart(2, '0')).join('');\n      \n      // Stocker le fichier dans le stockage local (sessionStorage)\n      const fileReader = new FileReader();\n      fileReader.readAsDataURL(file);\n      \n      const fileDataUrl = await new Promise((resolve, reject) => {\n        fileReader.onload = () => resolve(fileReader.result);\n        fileReader.onerror = reject;\n      });\n      \n      // Stocker le fichier dans sessionStorage\n      sessionStorage.setItem(`ipfs-file-${tempHash}`, fileDataUrl);\n      sessionStorage.setItem(`ipfs-file-name-${tempHash}`, file.name);\n      \n      console.log(`Fichier \"${file.name}\" stocké temporairement avec le hash: ${tempHash}`);\n      return tempHash;\n    }\n    \n    const data = await response.json();\n    console.log(`Fichier \"${file.name}\" téléchargé sur IPFS avec succès`);\n    console.log(`Hash IPFS: ${data.Hash}`);\n    \n    return data.Hash;\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS:', error);\n    \n    // Solution de secours en cas d'erreur\n    console.warn('Utilisation du stockage local temporaire suite à une erreur');\n    \n    // Générer un hash temporaire\n    const tempHash = 'Qm' + Array.from(crypto.getRandomValues(new Uint8Array(32)))\n      .map(b => b.toString(16).padStart(2, '0')).join('');\n    \n    // Stocker le fichier dans le stockage local (sessionStorage)\n    const fileReader = new FileReader();\n    fileReader.readAsDataURL(file);\n    \n    const fileDataUrl = await new Promise((resolve, reject) => {\n      fileReader.onload = () => resolve(fileReader.result);\n      fileReader.onerror = reject;\n    });\n    \n    // Stocker le fichier dans sessionStorage\n    sessionStorage.setItem(`ipfs-file-${tempHash}`, fileDataUrl);\n    sessionStorage.setItem(`ipfs-file-name-${tempHash}`, file.name);\n    \n    console.log(`Fichier \"${file.name}\" stocké temporairement avec le hash: ${tempHash}`);\n    return tempHash;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur IPFS\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = (ipfsHash) => {\n  if (!ipfsHash) return '';\n  \n  // Vérifier si le hash est dans notre stockage local temporaire\n  if (sessionStorage.getItem(`ipfs-file-${ipfsHash}`)) {\n    // Créer un blob URL à partir des données stockées\n    const dataUrl = sessionStorage.getItem(`ipfs-file-${ipfsHash}`);\n    return dataUrl;\n  }\n  \n  // Essayer plusieurs passerelles IPFS publiques (dans l'ordre de préférence)\n  // Note: Nous utilisons d'abord Cloudflare qui est plus fiable que ipfs.io\n  return `https://cloudflare-ipfs.com/ipfs/${ipfsHash}`;\n  \n  // Autres passerelles alternatives si nécessaire :\n  // return `https://gateway.pinata.cloud/ipfs/${ipfsHash}`;\n  // return `https://ipfs.io/ipfs/${ipfsHash}`;\n};\n\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}