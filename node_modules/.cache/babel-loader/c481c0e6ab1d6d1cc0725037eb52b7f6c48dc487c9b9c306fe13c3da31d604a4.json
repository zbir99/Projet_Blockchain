{"ast":null,"code":"/**\n * Solution de stockage local de fichiers pour démonstration\n * Cette version simule IPFS en stockant les fichiers dans le navigateur\n */\n\n// Stockage pour les fichiers\nconst localFileStorage = new Map();\n\n/**\n * Génère un identifiant unique pour simuler un CID IPFS\n * @returns {string} - Identifiant unique au format CID\n */\nconst generateFileId = () => {\n  // Générer un ID unique pour le fichier (format CID d'IPFS)\n  return 'Qm' + Array.from(crypto.getRandomValues(new Uint8Array(32))).map(b => b.toString(16).padStart(2, '0')).join('');\n};\n\n/**\n * Stocke un fichier localement et retourne un identifiant unique\n * @param {File} file - Le fichier à stocker\n * @returns {Promise<string>} - L'identifiant unique du fichier stocké\n */\nexport const uploadToIPFS = async file => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    console.log('Début du stockage du fichier...');\n\n    // Générer un ID unique pour le fichier\n    const fileId = generateFileId();\n\n    // Convertir le fichier en URL de données\n    const fileReader = new FileReader();\n    fileReader.readAsDataURL(file);\n    const fileDataUrl = await new Promise((resolve, reject) => {\n      fileReader.onload = () => resolve(fileReader.result);\n      fileReader.onerror = reject;\n    });\n\n    // Stocker les informations du fichier\n    const fileInfo = {\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      dataUrl: fileDataUrl,\n      date: new Date().toISOString()\n    };\n\n    // Stocker dans notre Map en mémoire et dans le sessionStorage pour la persistance\n    localFileStorage.set(fileId, fileInfo);\n    sessionStorage.setItem(`file-${fileId}`, JSON.stringify({\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      date: fileInfo.date\n    }));\n    sessionStorage.setItem(`file-data-${fileId}`, fileDataUrl);\n    console.log(`Fichier \"${file.name}\" stocké avec succès`);\n    console.log(`Identifiant: ${fileId}`);\n    return fileId;\n  } catch (error) {\n    console.error('Erreur lors du stockage du fichier:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupère l'URL d'accès à un fichier à partir de son identifiant\n * @param {string} fileId - L'identifiant du fichier\n * @returns {string} - L'URL pour accéder au fichier\n */\nexport const getIPFSGatewayURL = fileId => {\n  if (!fileId) return '';\n\n  // Vérifier d'abord dans notre Map en mémoire\n  if (localFileStorage.has(fileId)) {\n    return localFileStorage.get(fileId).dataUrl;\n  }\n\n  // Sinon, vérifier dans le sessionStorage\n  const fileData = sessionStorage.getItem(`file-data-${fileId}`);\n  if (fileData) {\n    return fileData;\n  }\n\n  // Si le fichier n'est pas trouvé, retourner une URL qui indique que le fichier n'est pas disponible\n  console.warn(`Fichier avec l'identifiant ${fileId} non trouvé`);\n  return '';\n};\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};","map":{"version":3,"names":["localFileStorage","Map","generateFileId","Array","from","crypto","getRandomValues","Uint8Array","map","b","toString","padStart","join","uploadToIPFS","file","Error","console","log","fileId","fileReader","FileReader","readAsDataURL","fileDataUrl","Promise","resolve","reject","onload","result","onerror","fileInfo","name","type","size","dataUrl","date","Date","toISOString","set","sessionStorage","setItem","JSON","stringify","error","getIPFSGatewayURL","has","get","fileData","getItem","warn"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["/**\n * Solution de stockage local de fichiers pour démonstration\n * Cette version simule IPFS en stockant les fichiers dans le navigateur\n */\n\n// Stockage pour les fichiers\nconst localFileStorage = new Map();\n\n/**\n * Génère un identifiant unique pour simuler un CID IPFS\n * @returns {string} - Identifiant unique au format CID\n */\nconst generateFileId = () => {\n  // Générer un ID unique pour le fichier (format CID d'IPFS)\n  return 'Qm' + Array.from(crypto.getRandomValues(new Uint8Array(32)))\n    .map(b => b.toString(16).padStart(2, '0')).join('');\n};\n\n/**\n * Stocke un fichier localement et retourne un identifiant unique\n * @param {File} file - Le fichier à stocker\n * @returns {Promise<string>} - L'identifiant unique du fichier stocké\n */\nexport const uploadToIPFS = async (file) => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    \n    console.log('Début du stockage du fichier...');\n    \n    // Générer un ID unique pour le fichier\n    const fileId = generateFileId();\n    \n    // Convertir le fichier en URL de données\n    const fileReader = new FileReader();\n    fileReader.readAsDataURL(file);\n    \n    const fileDataUrl = await new Promise((resolve, reject) => {\n      fileReader.onload = () => resolve(fileReader.result);\n      fileReader.onerror = reject;\n    });\n    \n    // Stocker les informations du fichier\n    const fileInfo = {\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      dataUrl: fileDataUrl,\n      date: new Date().toISOString()\n    };\n    \n    // Stocker dans notre Map en mémoire et dans le sessionStorage pour la persistance\n    localFileStorage.set(fileId, fileInfo);\n    sessionStorage.setItem(`file-${fileId}`, JSON.stringify({\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      date: fileInfo.date\n    }));\n    sessionStorage.setItem(`file-data-${fileId}`, fileDataUrl);\n    \n    console.log(`Fichier \"${file.name}\" stocké avec succès`);\n    console.log(`Identifiant: ${fileId}`);\n    \n    return fileId;\n  } catch (error) {\n    console.error('Erreur lors du stockage du fichier:', error);\n    throw error;\n  }\n};\n\n/**\n * Récupère l'URL d'accès à un fichier à partir de son identifiant\n * @param {string} fileId - L'identifiant du fichier\n * @returns {string} - L'URL pour accéder au fichier\n */\nexport const getIPFSGatewayURL = (fileId) => {\n  if (!fileId) return '';\n  \n  // Vérifier d'abord dans notre Map en mémoire\n  if (localFileStorage.has(fileId)) {\n    return localFileStorage.get(fileId).dataUrl;\n  }\n  \n  // Sinon, vérifier dans le sessionStorage\n  const fileData = sessionStorage.getItem(`file-data-${fileId}`);\n  if (fileData) {\n    return fileData;\n  }\n  \n  // Si le fichier n'est pas trouvé, retourner une URL qui indique que le fichier n'est pas disponible\n  console.warn(`Fichier avec l'identifiant ${fileId} non trouvé`);\n  return '';\n};\n\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}