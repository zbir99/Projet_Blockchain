{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\yassi\\\\OneDrive\\\\Desktop\\\\tp_9\\\\Certification-de-Diplomes\\\\src\\\\utils\\\\web3Provider.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { ethers } from 'ethers';\nimport CertificationABI from '../abis/Certification.json';\n\n// Créer un contexte pour le provider Web3\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Web3Context = /*#__PURE__*/createContext();\n\n// Récupérer l'adresse du contrat depuis les variables d'environnement\nconst contractAddress = process.env.REACT_APP_CONTRACT_ADDRESS || '0x0';\nexport const Web3Provider = ({\n  children\n}) => {\n  _s();\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const [contract, setContract] = useState(null);\n  const [account, setAccount] = useState('');\n  const [isAdmin, setIsAdmin] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const [networkId, setNetworkId] = useState(null);\n  const [error, setError] = useState('');\n\n  // Initialiser le provider et le contrat\n  useEffect(() => {\n    const init = async () => {\n      try {\n        if (window.ethereum) {\n          // Créer un provider ethers à partir de Metamask\n          const ethersProvider = new ethers.providers.Web3Provider(window.ethereum);\n          setProvider(ethersProvider);\n\n          // Écouter les changements d'account\n          window.ethereum.on('accountsChanged', handleAccountsChanged);\n\n          // Écouter les changements de réseau\n          window.ethereum.on('chainChanged', () => window.location.reload());\n\n          // Récupérer le network ID\n          const network = await ethersProvider.getNetwork();\n          setNetworkId(network.chainId);\n\n          // Récupérer le compte actuel s'il est déjà connecté\n          const accounts = await ethersProvider.listAccounts();\n          if (accounts.length > 0) {\n            handleAccountsChanged(accounts);\n          }\n        } else {\n          setError('Veuillez installer MetaMask pour utiliser cette application');\n        }\n      } catch (err) {\n        console.error('Erreur lors de l\\'initialisation du provider:', err);\n        setError('Erreur lors de la connexion à Ethereum');\n      }\n    };\n    init();\n\n    // Cleanup des listeners\n    return () => {\n      if (window.ethereum) {\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\n      }\n    };\n  }, []);\n\n  // Mettre à jour le signer et le contrat lorsque le compte change\n  useEffect(() => {\n    const initContract = async () => {\n      if (provider && account) {\n        try {\n          const signerInstance = provider.getSigner();\n          setSigner(signerInstance);\n\n          // Créer une instance du contrat\n          const contractInstance = new ethers.Contract(contractAddress, CertificationABI.abi, signerInstance);\n          setContract(contractInstance);\n\n          // Vérifier si l'utilisateur est administrateur\n          const adminRole = await contractInstance.ADMIN_ROLE();\n          const hasAdminRole = await contractInstance.hasRole(adminRole, account);\n          setIsAdmin(hasAdminRole);\n          setIsConnected(true);\n        } catch (err) {\n          console.error('Erreur lors de l\\'initialisation du contrat:', err);\n          setError('Erreur lors de la connexion au contrat intelligent');\n        }\n      }\n    };\n    if (account) {\n      initContract();\n    }\n  }, [provider, account]);\n\n  // Gérer les changements de compte\n  const handleAccountsChanged = async accounts => {\n    if (accounts.length === 0) {\n      // Utilisateur déconnecté\n      setAccount('');\n      setIsAdmin(false);\n      setIsConnected(false);\n    } else {\n      // Récupérer l'adresse du compte\n      const currentAccount = accounts[0].address || accounts[0];\n      setAccount(currentAccount);\n    }\n  };\n\n  // Connecter à MetaMask\n  const connectWallet = async () => {\n    try {\n      if (window.ethereum) {\n        // Demander à l'utilisateur de se connecter\n        const accounts = await window.ethereum.request({\n          method: 'eth_requestAccounts'\n        });\n        handleAccountsChanged(accounts);\n      } else {\n        setError('Veuillez installer MetaMask pour utiliser cette application');\n      }\n    } catch (err) {\n      console.error('Erreur lors de la connexion au wallet:', err);\n      setError('Erreur lors de la connexion à MetaMask');\n    }\n  };\n\n  // Déconnecter\n  const disconnectWallet = () => {\n    setAccount('');\n    setIsAdmin(false);\n    setIsConnected(false);\n  };\n\n  // Valeurs du contexte\n  const value = {\n    provider,\n    signer,\n    contract,\n    account,\n    isAdmin,\n    isConnected,\n    networkId,\n    error,\n    connectWallet,\n    disconnectWallet\n  };\n  return /*#__PURE__*/_jsxDEV(Web3Context.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 151,\n    columnNumber: 10\n  }, this);\n};\n\n// Hook personnalisé pour utiliser le contexte\n_s(Web3Provider, \"Zc8/vgPiOGk6ynvmIzlBsHvDWwU=\");\n_c = Web3Provider;\nexport const useProvider = () => {\n  _s2();\n  const context = useContext(Web3Context);\n  if (!context) {\n    throw new Error('useProvider doit être utilisé dans un Web3Provider');\n  }\n  return context;\n};\n_s2(useProvider, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default Web3Provider;\nvar _c;\n$RefreshReg$(_c, \"Web3Provider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","ethers","CertificationABI","jsxDEV","_jsxDEV","Web3Context","contractAddress","process","env","REACT_APP_CONTRACT_ADDRESS","Web3Provider","children","_s","provider","setProvider","signer","setSigner","contract","setContract","account","setAccount","isAdmin","setIsAdmin","isConnected","setIsConnected","networkId","setNetworkId","error","setError","init","window","ethereum","ethersProvider","providers","on","handleAccountsChanged","location","reload","network","getNetwork","chainId","accounts","listAccounts","length","err","console","removeListener","initContract","signerInstance","getSigner","contractInstance","Contract","abi","adminRole","ADMIN_ROLE","hasAdminRole","hasRole","currentAccount","address","connectWallet","request","method","disconnectWallet","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useProvider","_s2","context","Error","$RefreshReg$"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/web3Provider.js"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect } from 'react';\nimport { ethers } from 'ethers';\nimport CertificationABI from '../abis/Certification.json';\n\n// Créer un contexte pour le provider Web3\nconst Web3Context = createContext();\n\n// Récupérer l'adresse du contrat depuis les variables d'environnement\nconst contractAddress = process.env.REACT_APP_CONTRACT_ADDRESS || '0x0';\n\nexport const Web3Provider = ({ children }) => {\n  const [provider, setProvider] = useState(null);\n  const [signer, setSigner] = useState(null);\n  const [contract, setContract] = useState(null);\n  const [account, setAccount] = useState('');\n  const [isAdmin, setIsAdmin] = useState(false);\n  const [isConnected, setIsConnected] = useState(false);\n  const [networkId, setNetworkId] = useState(null);\n  const [error, setError] = useState('');\n\n  // Initialiser le provider et le contrat\n  useEffect(() => {\n    const init = async () => {\n      try {\n        if (window.ethereum) {\n          // Créer un provider ethers à partir de Metamask\n          const ethersProvider = new ethers.providers.Web3Provider(window.ethereum);\n          setProvider(ethersProvider);\n\n          // Écouter les changements d'account\n          window.ethereum.on('accountsChanged', handleAccountsChanged);\n          \n          // Écouter les changements de réseau\n          window.ethereum.on('chainChanged', () => window.location.reload());\n\n          // Récupérer le network ID\n          const network = await ethersProvider.getNetwork();\n          setNetworkId(network.chainId);\n\n          // Récupérer le compte actuel s'il est déjà connecté\n          const accounts = await ethersProvider.listAccounts();\n          if (accounts.length > 0) {\n            handleAccountsChanged(accounts);\n          }\n        } else {\n          setError('Veuillez installer MetaMask pour utiliser cette application');\n        }\n      } catch (err) {\n        console.error('Erreur lors de l\\'initialisation du provider:', err);\n        setError('Erreur lors de la connexion à Ethereum');\n      }\n    };\n\n    init();\n\n    // Cleanup des listeners\n    return () => {\n      if (window.ethereum) {\n        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);\n      }\n    };\n  }, []);\n\n  // Mettre à jour le signer et le contrat lorsque le compte change\n  useEffect(() => {\n    const initContract = async () => {\n      if (provider && account) {\n        try {\n          const signerInstance = provider.getSigner();\n          setSigner(signerInstance);\n\n          // Créer une instance du contrat\n          const contractInstance = new ethers.Contract(\n            contractAddress,\n            CertificationABI.abi,\n            signerInstance\n          );\n          setContract(contractInstance);\n\n          // Vérifier si l'utilisateur est administrateur\n          const adminRole = await contractInstance.ADMIN_ROLE();\n          const hasAdminRole = await contractInstance.hasRole(adminRole, account);\n          setIsAdmin(hasAdminRole);\n          \n          setIsConnected(true);\n        } catch (err) {\n          console.error('Erreur lors de l\\'initialisation du contrat:', err);\n          setError('Erreur lors de la connexion au contrat intelligent');\n        }\n      }\n    };\n\n    if (account) {\n      initContract();\n    }\n  }, [provider, account]);\n\n  // Gérer les changements de compte\n  const handleAccountsChanged = async (accounts) => {\n    if (accounts.length === 0) {\n      // Utilisateur déconnecté\n      setAccount('');\n      setIsAdmin(false);\n      setIsConnected(false);\n    } else {\n      // Récupérer l'adresse du compte\n      const currentAccount = accounts[0].address || accounts[0];\n      setAccount(currentAccount);\n    }\n  };\n\n  // Connecter à MetaMask\n  const connectWallet = async () => {\n    try {\n      if (window.ethereum) {\n        // Demander à l'utilisateur de se connecter\n        const accounts = await window.ethereum.request({\n          method: 'eth_requestAccounts'\n        });\n        handleAccountsChanged(accounts);\n      } else {\n        setError('Veuillez installer MetaMask pour utiliser cette application');\n      }\n    } catch (err) {\n      console.error('Erreur lors de la connexion au wallet:', err);\n      setError('Erreur lors de la connexion à MetaMask');\n    }\n  };\n\n  // Déconnecter\n  const disconnectWallet = () => {\n    setAccount('');\n    setIsAdmin(false);\n    setIsConnected(false);\n  };\n\n  // Valeurs du contexte\n  const value = {\n    provider,\n    signer,\n    contract,\n    account,\n    isAdmin,\n    isConnected,\n    networkId,\n    error,\n    connectWallet,\n    disconnectWallet\n  };\n\n  return <Web3Context.Provider value={value}>{children}</Web3Context.Provider>;\n};\n\n// Hook personnalisé pour utiliser le contexte\nexport const useProvider = () => {\n  const context = useContext(Web3Context);\n  if (!context) {\n    throw new Error('useProvider doit être utilisé dans un Web3Provider');\n  }\n  return context;\n};\n\nexport default Web3Provider;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}