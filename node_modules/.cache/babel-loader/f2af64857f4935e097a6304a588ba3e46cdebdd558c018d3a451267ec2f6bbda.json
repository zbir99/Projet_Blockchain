{"ast":null,"code":"/**\n * Service IPFS pour conteneur Docker ipfs-node\n * Optimis√© pour fonctionner avec votre configuration\n */\nimport { create } from 'ipfs-http-client';\nclass IPFSService {\n  constructor() {\n    this.client = null;\n    this.isConnected = false;\n    this.containerName = 'ipfs-node';\n    this.initialize();\n  }\n\n  /**\n   * Initialise la connexion IPFS avec le conteneur ipfs-node\n   */\n  async initialize() {\n    try {\n      // Configuration pour votre conteneur ipfs-node\n      this.client = create({\n        host: 'localhost',\n        port: 5001,\n        protocol: 'http'\n      });\n\n      // Tester la connexion\n      const version = await this.client.version();\n      this.isConnected = true;\n      console.log('‚úÖ IPFS conteneur ipfs-node connect√© avec succ√®s!');\n      console.log('üì¶ Version IPFS:', version.version);\n      console.log('üê≥ Conteneur:', this.containerName);\n    } catch (error) {\n      console.error('‚ùå Connexion √©chou√©e au conteneur ipfs-node:', error.message);\n      console.log('üîß Solutions possibles:');\n      console.log('1. V√©rifiez que le conteneur est d√©marr√©: docker ps | grep ipfs-node');\n      console.log('2. Configurez CORS: docker exec -it ipfs-node ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin \\'[\"*\"]\\'');\n      console.log('3. Red√©marrez: docker restart ipfs-node');\n      this.isConnected = false;\n    }\n  }\n\n  /**\n   * V√©rifie la connexion au conteneur ipfs-node\n   */\n  async checkConnection() {\n    try {\n      if (!this.client) {\n        await this.initialize();\n      }\n      const version = await this.client.version();\n      this.isConnected = true;\n      return true;\n    } catch (error) {\n      console.error('‚ùå Conteneur ipfs-node non accessible:', error.message);\n      this.isConnected = false;\n      return false;\n    }\n  }\n\n  /**\n   * Upload un fichier sur IPFS conteneur ipfs-node\n   * @param {File} file - Le fichier √† uploader\n   * @returns {Promise<string>} - Le hash IPFS\n   */\n  async uploadFile(file) {\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    console.log('üì§ Upload sur conteneur ipfs-node...');\n    console.log('üìÑ Fichier:', file.name);\n    console.log('üìä Taille:', (file.size / 1024 / 1024).toFixed(2), 'MB');\n\n    // V√©rifier la connexion\n    const isConnected = await this.checkConnection();\n    if (!isConnected) {\n      throw new Error('Conteneur ipfs-node non disponible. V√©rifiez: docker ps | grep ipfs-node');\n    }\n    try {\n      // Convertir le fichier en ArrayBuffer puis Uint8Array\n      const arrayBuffer = await file.arrayBuffer();\n      const fileContent = new Uint8Array(arrayBuffer);\n      console.log('‚è≥ Upload en cours...');\n\n      // Upload sur IPFS avec gestion du progr√®s\n      const result = await this.client.add({\n        path: file.name,\n        content: fileContent\n      }, {\n        pin: true,\n        // √âpingler pour √©viter la suppression\n        progress: bytes => {\n          const percent = (bytes / file.size * 100).toFixed(1);\n          console.log(`üìä Progression: ${percent}% (${bytes}/${file.size} bytes)`);\n        }\n      });\n      const ipfsHash = result.cid.toString();\n      console.log('‚úÖ Upload r√©ussi sur ipfs-node!');\n      console.log('üîó Hash IPFS:', ipfsHash);\n      console.log('üåê URL:', this.getGatewayURL(ipfsHash));\n\n      // V√©rifier que le fichier est accessible\n      setTimeout(async () => {\n        try {\n          const isAccessible = await this.verifyFileAccess(ipfsHash);\n          console.log(isAccessible ? '‚úÖ Fichier accessible via gateway' : '‚ö†Ô∏è Fichier pas encore accessible');\n        } catch (error) {\n          console.warn('‚ö†Ô∏è V√©rification d\\'acc√®s √©chou√©e:', error.message);\n        }\n      }, 1000);\n      return ipfsHash;\n    } catch (error) {\n      console.error('‚ùå Erreur upload sur ipfs-node:', error);\n\n      // Messages d'erreur sp√©cifiques\n      if (error.code === 'ECONNREFUSED') {\n        throw new Error('Conteneur ipfs-node non accessible. V√©rifiez: docker restart ipfs-node');\n      } else if (error.message.includes('fetch')) {\n        throw new Error('Erreur CORS. Configurez: docker exec -it ipfs-node ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin \\'[\"*\"]\\'');\n      } else {\n        throw new Error(`Erreur upload: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Upload des donn√©es JSON sur ipfs-node\n   * @param {Object} data - Les donn√©es √† uploader\n   * @returns {Promise<string>} - Le hash IPFS\n   */\n  async uploadJSON(data) {\n    console.log('üì§ Upload JSON sur ipfs-node...');\n    console.log('üìÑ Donn√©es:', data);\n    const isConnected = await this.checkConnection();\n    if (!isConnected) {\n      throw new Error('Conteneur ipfs-node non disponible');\n    }\n    try {\n      const jsonString = JSON.stringify(data, null, 2);\n      console.log('üìù JSON format√©:', jsonString.length, 'caract√®res');\n      const result = await this.client.add(jsonString, {\n        pin: true,\n        timeout: 10000 // 10 secondes de timeout\n      });\n      const ipfsHash = result.cid.toString();\n      console.log('‚úÖ JSON upload√© avec succ√®s!');\n      console.log('üîó Hash IPFS:', ipfsHash);\n      return ipfsHash;\n    } catch (error) {\n      console.error('‚ùå Erreur upload JSON:', error);\n      throw new Error(`Erreur upload JSON sur ipfs-node: ${error.message}`);\n    }\n  }\n\n  /**\n   * V√©rifie qu'un fichier est accessible via la gateway\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {Promise<boolean>} - True si accessible\n   */\n  async verifyFileAccess(ipfsHash) {\n    try {\n      const url = this.getGatewayURL(ipfsHash);\n      const response = await fetch(url, {\n        method: 'HEAD',\n        timeout: 5000\n      });\n      return response.ok;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * URL de la gateway IPFS pour ipfs-node\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {string} - L'URL compl√®te\n   */\n  getGatewayURL(ipfsHash) {\n    if (!ipfsHash) return '';\n    return `http://localhost:8080/ipfs/${ipfsHash}`;\n  }\n\n  /**\n   * Informations sur un fichier IPFS\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {Promise<Object>} - Les informations du fichier\n   */\n  async getFileInfo(ipfsHash) {\n    if (!this.isConnected) {\n      throw new Error('ipfs-node non connect√©');\n    }\n    try {\n      // Essayer de r√©cup√©rer les stats via l'API\n      const stats = await this.client.object.stat(ipfsHash);\n      return {\n        hash: ipfsHash,\n        size: stats.CumulativeSize || stats.DataSize || 0,\n        links: stats.NumLinks || 0,\n        url: this.getGatewayURL(ipfsHash),\n        accessible: true,\n        container: this.containerName\n      };\n    } catch (error) {\n      return {\n        hash: ipfsHash,\n        size: 0,\n        links: 0,\n        url: this.getGatewayURL(ipfsHash),\n        accessible: false,\n        error: error.message,\n        container: this.containerName\n      };\n    }\n  }\n\n  /**\n   * Statut du service IPFS ipfs-node\n   * @returns {Object} - Informations d√©taill√©es\n   */\n  getStatus() {\n    return {\n      connected: this.isConnected,\n      container: this.containerName,\n      type: 'Docker',\n      host: 'localhost',\n      apiPort: 5001,\n      gatewayPort: 8080,\n      protocol: 'http',\n      apiUrl: 'http://localhost:5001',\n      gatewayUrl: 'http://localhost:8080',\n      webuiUrl: 'http://localhost:5001/webui'\n    };\n  }\n\n  /**\n   * Diagnostic complet du conteneur ipfs-node\n   * @returns {Promise<Object>} - R√©sultats des tests\n   */\n  async runDiagnostics() {\n    console.log('üîç Diagnostic du conteneur ipfs-node...');\n    const results = {\n      container: this.containerName,\n      api: false,\n      gateway: false,\n      upload: false,\n      version: null,\n      errors: []\n    };\n    try {\n      // Test API\n      const version = await this.client.version();\n      results.api = true;\n      results.version = version.version;\n      console.log('‚úÖ API ipfs-node accessible');\n    } catch (error) {\n      results.errors.push(`API: ${error.message}`);\n      console.error('‚ùå API ipfs-node non accessible');\n    }\n    try {\n      // Test Gateway\n      const response = await fetch('http://localhost:8080/ipfs/QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn');\n      results.gateway = response.ok;\n      console.log(results.gateway ? '‚úÖ Gateway accessible' : '‚ùå Gateway non accessible');\n    } catch (error) {\n      results.errors.push(`Gateway: ${error.message}`);\n    }\n    try {\n      // Test Upload\n      const testData = `Test ipfs-node ${new Date().toISOString()}`;\n      const result = await this.client.add(testData);\n      results.upload = true;\n      console.log('‚úÖ Upload fonctionnel:', result.cid.toString());\n    } catch (error) {\n      results.errors.push(`Upload: ${error.message}`);\n    }\n    return results;\n  }\n}\n\n// Instance unique du service\nconst ipfsService = new IPFSService();\n\n// Exports pour compatibilit√©\nexport const uploadToIPFS = file => ipfsService.uploadFile(file);\nexport const getIPFSGatewayURL = hash => ipfsService.getGatewayURL(hash);\nexport default ipfsService;","map":{"version":3,"names":["create","IPFSService","constructor","client","isConnected","containerName","initialize","host","port","protocol","version","console","log","error","message","checkConnection","uploadFile","file","Error","name","size","toFixed","arrayBuffer","fileContent","Uint8Array","result","add","path","content","pin","progress","bytes","percent","ipfsHash","cid","toString","getGatewayURL","setTimeout","isAccessible","verifyFileAccess","warn","code","includes","uploadJSON","data","jsonString","JSON","stringify","length","timeout","url","response","fetch","method","ok","getFileInfo","stats","object","stat","hash","CumulativeSize","DataSize","links","NumLinks","accessible","container","getStatus","connected","type","apiPort","gatewayPort","apiUrl","gatewayUrl","webuiUrl","runDiagnostics","results","api","gateway","upload","errors","push","testData","Date","toISOString","ipfsService","uploadToIPFS","getIPFSGatewayURL"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["/**\n * Service IPFS pour conteneur Docker ipfs-node\n * Optimis√© pour fonctionner avec votre configuration\n */\nimport { create } from 'ipfs-http-client';\n\nclass IPFSService {\n  constructor() {\n    this.client = null;\n    this.isConnected = false;\n    this.containerName = 'ipfs-node';\n    this.initialize();\n  }\n\n  /**\n   * Initialise la connexion IPFS avec le conteneur ipfs-node\n   */\n  async initialize() {\n    try {\n      // Configuration pour votre conteneur ipfs-node\n      this.client = create({\n        host: 'localhost',\n        port: 5001,\n        protocol: 'http'\n      });\n\n      // Tester la connexion\n      const version = await this.client.version();\n      this.isConnected = true;\n      \n      console.log('‚úÖ IPFS conteneur ipfs-node connect√© avec succ√®s!');\n      console.log('üì¶ Version IPFS:', version.version);\n      console.log('üê≥ Conteneur:', this.containerName);\n      \n    } catch (error) {\n      console.error('‚ùå Connexion √©chou√©e au conteneur ipfs-node:', error.message);\n      console.log('üîß Solutions possibles:');\n      console.log('1. V√©rifiez que le conteneur est d√©marr√©: docker ps | grep ipfs-node');\n      console.log('2. Configurez CORS: docker exec -it ipfs-node ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin \\'[\"*\"]\\'');\n      console.log('3. Red√©marrez: docker restart ipfs-node');\n      \n      this.isConnected = false;\n    }\n  }\n\n  /**\n   * V√©rifie la connexion au conteneur ipfs-node\n   */\n  async checkConnection() {\n    try {\n      if (!this.client) {\n        await this.initialize();\n      }\n\n      const version = await this.client.version();\n      this.isConnected = true;\n      return true;\n      \n    } catch (error) {\n      console.error('‚ùå Conteneur ipfs-node non accessible:', error.message);\n      this.isConnected = false;\n      return false;\n    }\n  }\n\n  /**\n   * Upload un fichier sur IPFS conteneur ipfs-node\n   * @param {File} file - Le fichier √† uploader\n   * @returns {Promise<string>} - Le hash IPFS\n   */\n  async uploadFile(file) {\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n\n    console.log('üì§ Upload sur conteneur ipfs-node...');\n    console.log('üìÑ Fichier:', file.name);\n    console.log('üìä Taille:', (file.size / 1024 / 1024).toFixed(2), 'MB');\n\n    // V√©rifier la connexion\n    const isConnected = await this.checkConnection();\n    if (!isConnected) {\n      throw new Error('Conteneur ipfs-node non disponible. V√©rifiez: docker ps | grep ipfs-node');\n    }\n\n    try {\n      // Convertir le fichier en ArrayBuffer puis Uint8Array\n      const arrayBuffer = await file.arrayBuffer();\n      const fileContent = new Uint8Array(arrayBuffer);\n\n      console.log('‚è≥ Upload en cours...');\n\n      // Upload sur IPFS avec gestion du progr√®s\n      const result = await this.client.add({\n        path: file.name,\n        content: fileContent\n      }, {\n        pin: true, // √âpingler pour √©viter la suppression\n        progress: (bytes) => {\n          const percent = ((bytes / file.size) * 100).toFixed(1);\n          console.log(`üìä Progression: ${percent}% (${bytes}/${file.size} bytes)`);\n        }\n      });\n\n      const ipfsHash = result.cid.toString();\n      \n      console.log('‚úÖ Upload r√©ussi sur ipfs-node!');\n      console.log('üîó Hash IPFS:', ipfsHash);\n      console.log('üåê URL:', this.getGatewayURL(ipfsHash));\n\n      // V√©rifier que le fichier est accessible\n      setTimeout(async () => {\n        try {\n          const isAccessible = await this.verifyFileAccess(ipfsHash);\n          console.log(isAccessible ? '‚úÖ Fichier accessible via gateway' : '‚ö†Ô∏è Fichier pas encore accessible');\n        } catch (error) {\n          console.warn('‚ö†Ô∏è V√©rification d\\'acc√®s √©chou√©e:', error.message);\n        }\n      }, 1000);\n\n      return ipfsHash;\n\n    } catch (error) {\n      console.error('‚ùå Erreur upload sur ipfs-node:', error);\n      \n      // Messages d'erreur sp√©cifiques\n      if (error.code === 'ECONNREFUSED') {\n        throw new Error('Conteneur ipfs-node non accessible. V√©rifiez: docker restart ipfs-node');\n      } else if (error.message.includes('fetch')) {\n        throw new Error('Erreur CORS. Configurez: docker exec -it ipfs-node ipfs config --json API.HTTPHeaders.Access-Control-Allow-Origin \\'[\"*\"]\\'');\n      } else {\n        throw new Error(`Erreur upload: ${error.message}`);\n      }\n    }\n  }\n\n  /**\n   * Upload des donn√©es JSON sur ipfs-node\n   * @param {Object} data - Les donn√©es √† uploader\n   * @returns {Promise<string>} - Le hash IPFS\n   */\n  async uploadJSON(data) {\n    console.log('üì§ Upload JSON sur ipfs-node...');\n    console.log('üìÑ Donn√©es:', data);\n    \n    const isConnected = await this.checkConnection();\n    if (!isConnected) {\n      throw new Error('Conteneur ipfs-node non disponible');\n    }\n\n    try {\n      const jsonString = JSON.stringify(data, null, 2);\n      console.log('üìù JSON format√©:', jsonString.length, 'caract√®res');\n\n      const result = await this.client.add(jsonString, { \n        pin: true,\n        timeout: 10000 // 10 secondes de timeout\n      });\n      \n      const ipfsHash = result.cid.toString();\n      console.log('‚úÖ JSON upload√© avec succ√®s!');\n      console.log('üîó Hash IPFS:', ipfsHash);\n      \n      return ipfsHash;\n\n    } catch (error) {\n      console.error('‚ùå Erreur upload JSON:', error);\n      throw new Error(`Erreur upload JSON sur ipfs-node: ${error.message}`);\n    }\n  }\n\n  /**\n   * V√©rifie qu'un fichier est accessible via la gateway\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {Promise<boolean>} - True si accessible\n   */\n  async verifyFileAccess(ipfsHash) {\n    try {\n      const url = this.getGatewayURL(ipfsHash);\n      const response = await fetch(url, { \n        method: 'HEAD',\n        timeout: 5000 \n      });\n      return response.ok;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * URL de la gateway IPFS pour ipfs-node\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {string} - L'URL compl√®te\n   */\n  getGatewayURL(ipfsHash) {\n    if (!ipfsHash) return '';\n    return `http://localhost:8080/ipfs/${ipfsHash}`;\n  }\n\n  /**\n   * Informations sur un fichier IPFS\n   * @param {string} ipfsHash - Le hash IPFS\n   * @returns {Promise<Object>} - Les informations du fichier\n   */\n  async getFileInfo(ipfsHash) {\n    if (!this.isConnected) {\n      throw new Error('ipfs-node non connect√©');\n    }\n\n    try {\n      // Essayer de r√©cup√©rer les stats via l'API\n      const stats = await this.client.object.stat(ipfsHash);\n      \n      return {\n        hash: ipfsHash,\n        size: stats.CumulativeSize || stats.DataSize || 0,\n        links: stats.NumLinks || 0,\n        url: this.getGatewayURL(ipfsHash),\n        accessible: true,\n        container: this.containerName\n      };\n    } catch (error) {\n      return {\n        hash: ipfsHash,\n        size: 0,\n        links: 0,\n        url: this.getGatewayURL(ipfsHash),\n        accessible: false,\n        error: error.message,\n        container: this.containerName\n      };\n    }\n  }\n\n  /**\n   * Statut du service IPFS ipfs-node\n   * @returns {Object} - Informations d√©taill√©es\n   */\n  getStatus() {\n    return {\n      connected: this.isConnected,\n      container: this.containerName,\n      type: 'Docker',\n      host: 'localhost',\n      apiPort: 5001,\n      gatewayPort: 8080,\n      protocol: 'http',\n      apiUrl: 'http://localhost:5001',\n      gatewayUrl: 'http://localhost:8080',\n      webuiUrl: 'http://localhost:5001/webui'\n    };\n  }\n\n  /**\n   * Diagnostic complet du conteneur ipfs-node\n   * @returns {Promise<Object>} - R√©sultats des tests\n   */\n  async runDiagnostics() {\n    console.log('üîç Diagnostic du conteneur ipfs-node...');\n    const results = {\n      container: this.containerName,\n      api: false,\n      gateway: false,\n      upload: false,\n      version: null,\n      errors: []\n    };\n\n    try {\n      // Test API\n      const version = await this.client.version();\n      results.api = true;\n      results.version = version.version;\n      console.log('‚úÖ API ipfs-node accessible');\n      \n    } catch (error) {\n      results.errors.push(`API: ${error.message}`);\n      console.error('‚ùå API ipfs-node non accessible');\n    }\n\n    try {\n      // Test Gateway\n      const response = await fetch('http://localhost:8080/ipfs/QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn');\n      results.gateway = response.ok;\n      console.log(results.gateway ? '‚úÖ Gateway accessible' : '‚ùå Gateway non accessible');\n      \n    } catch (error) {\n      results.errors.push(`Gateway: ${error.message}`);\n    }\n\n    try {\n      // Test Upload\n      const testData = `Test ipfs-node ${new Date().toISOString()}`;\n      const result = await this.client.add(testData);\n      results.upload = true;\n      console.log('‚úÖ Upload fonctionnel:', result.cid.toString());\n      \n    } catch (error) {\n      results.errors.push(`Upload: ${error.message}`);\n    }\n\n    return results;\n  }\n}\n\n// Instance unique du service\nconst ipfsService = new IPFSService();\n\n// Exports pour compatibilit√©\nexport const uploadToIPFS = (file) => ipfsService.uploadFile(file);\nexport const getIPFSGatewayURL = (hash) => ipfsService.getGatewayURL(hash);\n\nexport default ipfsService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}