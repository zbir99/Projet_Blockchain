{"ast":null,"code":"import { IpNet } from '@chainsafe/netmask';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { bases } from 'multiformats/basics';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as varint from 'uint8-varint';\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport * as ip from './ip.js';\nimport { getProtocol } from './protocols-table.js';\nconst ip4Protocol = getProtocol('ip4');\nconst ip6Protocol = getProtocol('ip6');\nconst ipcidrProtocol = getProtocol('ipcidr');\nexport function convert(proto, a) {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a);\n  } else {\n    return convertToBytes(proto, a);\n  }\n}\n/**\n * Convert [code,Uint8Array] to string\n */\n// eslint-disable-next-line complexity\nexport function convertToString(proto, buf) {\n  const protocol = getProtocol(proto);\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41:\n      // ipv6\n      return bytes2ip(buf);\n    case 42:\n      // ipv6zone\n      return bytes2str(buf);\n    case 43:\n      // ipcidr\n      return uint8ArrayToString(buf, 'base10');\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132:\n      // sctp\n      return bytes2port(buf).toString();\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777:\n      // memory\n      return bytes2str(buf);\n    case 421:\n      // ipfs\n      return bytes2mh(buf);\n    case 444:\n      // onion\n      return bytes2onion(buf);\n    case 445:\n      // onion3\n      return bytes2onion(buf);\n    case 466:\n      // certhash\n      return bytes2mb(buf);\n    case 481:\n      // http-path\n      return globalThis.encodeURIComponent(bytes2str(buf));\n    default:\n      return uint8ArrayToString(buf, 'base16');\n    // no clue. convert to hex\n  }\n}\n// eslint-disable-next-line complexity\nexport function convertToBytes(proto, str) {\n  const protocol = getProtocol(proto);\n  switch (protocol.code) {\n    case 4:\n      // ipv4\n      return ip2bytes(str);\n    case 41:\n      // ipv6\n      return ip2bytes(str);\n    case 42:\n      // ipv6zone\n      return str2bytes(str);\n    case 43:\n      // ipcidr\n      return uint8ArrayFromString(str, 'base10');\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132:\n      // sctp\n      return port2bytes(parseInt(str, 10));\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777:\n      // memory\n      return str2bytes(str);\n    case 421:\n      // ipfs\n      return mh2bytes(str);\n    case 444:\n      // onion\n      return onion2bytes(str);\n    case 445:\n      // onion3\n      return onion32bytes(str);\n    case 466:\n      // certhash\n      return mb2bytes(str);\n    case 481:\n      // http-path\n      return str2bytes(globalThis.decodeURIComponent(str));\n    default:\n      return uint8ArrayFromString(str, 'base16');\n    // no clue. convert from hex\n  }\n}\nexport function convertToIpNet(multiaddr) {\n  let mask;\n  let addr;\n  multiaddr.stringTuples().forEach(([code, value]) => {\n    if (code === ip4Protocol.code || code === ip6Protocol.code) {\n      addr = value;\n    }\n    if (code === ipcidrProtocol.code) {\n      mask = value;\n    }\n  });\n  if (mask == null || addr == null) {\n    throw new Error('Invalid multiaddr');\n  }\n  return new IpNet(addr, mask);\n}\nconst decoders = Object.values(bases).map(c => c.decoder);\nconst anybaseDecoder = function () {\n  let acc = decoders[0].or(decoders[1]);\n  decoders.slice(2).forEach(d => acc = acc.or(d));\n  return acc;\n}();\nfunction ip2bytes(ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n  return ip.toBytes(ipString);\n}\nfunction bytes2ip(ipBuff) {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length);\n  if (ipString == null) {\n    throw new Error('ipBuff is required');\n  }\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n  return ipString;\n}\nfunction port2bytes(port) {\n  const buf = new ArrayBuffer(2);\n  const view = new DataView(buf);\n  view.setUint16(0, port);\n  return new Uint8Array(buf);\n}\nfunction bytes2port(buf) {\n  const view = new DataView(buf.buffer);\n  return view.getUint16(buf.byteOffset);\n}\nfunction str2bytes(str) {\n  const buf = uint8ArrayFromString(str);\n  const size = Uint8Array.from(varint.encode(buf.length));\n  return uint8ArrayConcat([size, buf], size.length + buf.length);\n}\nfunction bytes2str(buf) {\n  const size = varint.decode(buf);\n  buf = buf.slice(varint.encodingLength(size));\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n  return uint8ArrayToString(buf);\n}\nfunction mh2bytes(hash) {\n  let mh;\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes;\n  } else {\n    mh = CID.parse(hash).multihash.bytes;\n  }\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length));\n  return uint8ArrayConcat([size, mh], size.length + mh.length);\n}\nfunction mb2bytes(mbstr) {\n  const mb = anybaseDecoder.decode(mbstr);\n  const size = Uint8Array.from(varint.encode(mb.length));\n  return uint8ArrayConcat([size, mb], size.length + mb.length);\n}\nfunction bytes2mb(buf) {\n  const size = varint.decode(buf);\n  const hash = buf.slice(varint.encodingLength(size));\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n  return 'u' + uint8ArrayToString(hash, 'base64url');\n}\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh(buf) {\n  const size = varint.decode(buf);\n  const address = buf.slice(varint.encodingLength(size));\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n  return uint8ArrayToString(address, 'base58btc');\n}\nfunction onion2bytes(str) {\n  const addr = str.split(':');\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0]);\n  // onion port number\n  const port = parseInt(addr[1], 10);\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction onion32bytes(str) {\n  const addr = str.split(':');\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`);\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`);\n  // onion port number\n  const port = parseInt(addr[1], 10);\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n  const portBuf = port2bytes(port);\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);\n}\nfunction bytes2onion(buf) {\n  const addrBytes = buf.slice(0, buf.length - 2);\n  const portBytes = buf.slice(buf.length - 2);\n  const addr = uint8ArrayToString(addrBytes, 'base32');\n  const port = bytes2port(portBytes);\n  return `${addr}:${port}`;\n}","map":{"version":3,"names":["IpNet","base32","base58btc","bases","CID","Digest","varint","concat","uint8ArrayConcat","fromString","uint8ArrayFromString","toString","uint8ArrayToString","ip","getProtocol","ip4Protocol","ip6Protocol","ipcidrProtocol","convert","proto","a","Uint8Array","convertToString","convertToBytes","buf","protocol","code","bytes2ip","bytes2str","bytes2port","bytes2mh","bytes2onion","bytes2mb","globalThis","encodeURIComponent","str","ip2bytes","str2bytes","port2bytes","parseInt","mh2bytes","onion2bytes","onion32bytes","mb2bytes","decodeURIComponent","convertToIpNet","multiaddr","mask","addr","stringTuples","forEach","value","Error","decoders","Object","values","map","c","decoder","anybaseDecoder","acc","or","slice","d","ipString","isIP","toBytes","ipBuff","length","port","ArrayBuffer","view","DataView","setUint16","buffer","getUint16","byteOffset","size","from","encode","decode","encodingLength","hash","mh","bytes","parse","multihash","mbstr","mb","address","split","join","portBuf","addrBytes","portBytes"],"sources":["C:\\Users\\yassi\\OneDrive\\Desktop\\tp_9\\Certification-de-Diplomes\\node_modules\\@multiformats\\multiaddr-to-uri\\node_modules\\@multiformats\\multiaddr\\src\\convert.ts"],"sourcesContent":["import { IpNet } from '@chainsafe/netmask'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { bases } from 'multiformats/basics'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as varint from 'uint8-varint'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as ip from './ip.js'\nimport { getProtocol } from './protocols-table.js'\nimport type { Multiaddr } from './index.js'\n\nconst ip4Protocol = getProtocol('ip4')\nconst ip6Protocol = getProtocol('ip6')\nconst ipcidrProtocol = getProtocol('ipcidr')\n\n/**\n * converts (serializes) addresses\n */\nexport function convert (proto: string, a: string): Uint8Array\nexport function convert (proto: string, a: Uint8Array): string\nexport function convert (proto: string, a: string | Uint8Array): Uint8Array | string {\n  if (a instanceof Uint8Array) {\n    return convertToString(proto, a)\n  } else {\n    return convertToBytes(proto, a)\n  }\n}\n\n/**\n * Convert [code,Uint8Array] to string\n */\n// eslint-disable-next-line complexity\nexport function convertToString (proto: number | string, buf: Uint8Array): string {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n    case 41: // ipv6\n      return bytes2ip(buf)\n    case 42: // ipv6zone\n      return bytes2str(buf)\n    case 43: // ipcidr\n      return uint8ArrayToString(buf, 'base10')\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return bytes2port(buf).toString()\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return bytes2str(buf)\n\n    case 421: // ipfs\n      return bytes2mh(buf)\n    case 444: // onion\n      return bytes2onion(buf)\n    case 445: // onion3\n      return bytes2onion(buf)\n    case 466: // certhash\n      return bytes2mb(buf)\n    case 481: // http-path\n      return globalThis.encodeURIComponent(bytes2str(buf))\n    default:\n      return uint8ArrayToString(buf, 'base16') // no clue. convert to hex\n  }\n}\n\n// eslint-disable-next-line complexity\nexport function convertToBytes (proto: string | number, str: string): Uint8Array {\n  const protocol = getProtocol(proto)\n  switch (protocol.code) {\n    case 4: // ipv4\n      return ip2bytes(str)\n    case 41: // ipv6\n      return ip2bytes(str)\n    case 42: // ipv6zone\n      return str2bytes(str)\n    case 43: // ipcidr\n      return uint8ArrayFromString(str, 'base10')\n\n    case 6: // tcp\n    case 273: // udp\n    case 33: // dccp\n    case 132: // sctp\n      return port2bytes(parseInt(str, 10))\n\n    case 53: // dns\n    case 54: // dns4\n    case 55: // dns6\n    case 56: // dnsaddr\n    case 400: // unix\n    case 449: // sni\n    case 777: // memory\n      return str2bytes(str)\n\n    case 421: // ipfs\n      return mh2bytes(str)\n    case 444: // onion\n      return onion2bytes(str)\n    case 445: // onion3\n      return onion32bytes(str)\n    case 466: // certhash\n      return mb2bytes(str)\n    case 481: // http-path\n      return str2bytes(globalThis.decodeURIComponent(str))\n    default:\n      return uint8ArrayFromString(str, 'base16') // no clue. convert from hex\n  }\n}\n\nexport function convertToIpNet (multiaddr: Multiaddr): IpNet {\n  let mask: string | undefined\n  let addr: string | undefined\n  multiaddr.stringTuples().forEach(([code, value]) => {\n    if (code === ip4Protocol.code || code === ip6Protocol.code) {\n      addr = value\n    }\n    if (code === ipcidrProtocol.code) {\n      mask = value\n    }\n  })\n  if (mask == null || addr == null) {\n    throw new Error('Invalid multiaddr')\n  }\n  return new IpNet(addr, mask)\n}\n\nconst decoders = Object.values(bases).map((c) => c.decoder)\nconst anybaseDecoder = (function () {\n  let acc = decoders[0].or(decoders[1])\n  decoders.slice(2).forEach((d) => (acc = acc.or(d)))\n  return acc\n})()\n\nfunction ip2bytes (ipString: string): Uint8Array {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ip.toBytes(ipString)\n}\n\nfunction bytes2ip (ipBuff: Uint8Array): string {\n  const ipString = ip.toString(ipBuff, 0, ipBuff.length)\n  if (ipString == null) {\n    throw new Error('ipBuff is required')\n  }\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address')\n  }\n  return ipString\n}\n\nfunction port2bytes (port: number): Uint8Array {\n  const buf = new ArrayBuffer(2)\n  const view = new DataView(buf)\n  view.setUint16(0, port)\n\n  return new Uint8Array(buf)\n}\n\nfunction bytes2port (buf: Uint8Array): number {\n  const view = new DataView(buf.buffer)\n  return view.getUint16(buf.byteOffset)\n}\n\nfunction str2bytes (str: string): Uint8Array {\n  const buf = uint8ArrayFromString(str)\n  const size = Uint8Array.from(varint.encode(buf.length))\n  return uint8ArrayConcat([size, buf], size.length + buf.length)\n}\n\nfunction bytes2str (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  buf = buf.slice(varint.encodingLength(size))\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(buf)\n}\n\nfunction mh2bytes (hash: string): Uint8Array {\n  let mh\n\n  if (hash[0] === 'Q' || hash[0] === '1') {\n    mh = Digest.decode(base58btc.decode(`z${hash}`)).bytes\n  } else {\n    mh = CID.parse(hash).multihash.bytes\n  }\n\n  // the address is a varint prefixed multihash string representation\n  const size = Uint8Array.from(varint.encode(mh.length))\n  return uint8ArrayConcat([size, mh], size.length + mh.length)\n}\n\nfunction mb2bytes (mbstr: string): Uint8Array {\n  const mb = anybaseDecoder.decode(mbstr)\n  const size = Uint8Array.from(varint.encode(mb.length))\n  return uint8ArrayConcat([size, mb], size.length + mb.length)\n}\nfunction bytes2mb (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const hash = buf.slice(varint.encodingLength(size))\n\n  if (hash.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return 'u' + uint8ArrayToString(hash, 'base64url')\n}\n\n/**\n * Converts bytes to bas58btc string\n */\nfunction bytes2mh (buf: Uint8Array): string {\n  const size = varint.decode(buf)\n  const address = buf.slice(varint.encodingLength(size))\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths')\n  }\n\n  return uint8ArrayToString(address, 'base58btc')\n}\n\nfunction onion2bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 16) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`)\n  }\n\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode('b' + addr[0])\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction onion32bytes (str: string): Uint8Array {\n  const addr = str.split(':')\n  if (addr.length !== 2) {\n    throw new Error(`failed to parse onion addr: [\"'${addr.join('\", \"')}'\"]' does not contain a port number`)\n  }\n  if (addr[0].length !== 56) {\n    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`)\n  }\n  // onion addresses do not include the multibase prefix, add it before decoding\n  const buf = base32.decode(`b${addr[0]}`)\n\n  // onion port number\n  const port = parseInt(addr[1], 10)\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)')\n  }\n  const portBuf = port2bytes(port)\n  return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length)\n}\n\nfunction bytes2onion (buf: Uint8Array): string {\n  const addrBytes = buf.slice(0, buf.length - 2)\n  const portBytes = buf.slice(buf.length - 2)\n  const addr = uint8ArrayToString(addrBytes, 'base32')\n  const port = bytes2port(portBytes)\n  return `${addr}:${port}`\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}