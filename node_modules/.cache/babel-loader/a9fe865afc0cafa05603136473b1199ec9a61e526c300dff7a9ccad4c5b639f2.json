{"ast":null,"code":"/**\n * Utilitaire pour interagir avec IPFS via Docker\n */\n\n/**\n * Télécharge un fichier sur IPFS en utilisant l'API HTTP directement\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS du fichier téléchargé\n */\nexport const uploadToIPFS = async file => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    console.log('Début du téléchargement sur IPFS...');\n\n    // Créer un objet FormData pour l'envoi du fichier\n    const formData = new FormData();\n    formData.append('file', file);\n\n    // Utiliser l'API IPFS locale via Docker\n    const response = await fetch('http://localhost:5001/api/v0/add?pin=true', {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) {\n      throw new Error(`Erreur HTTP: ${response.status}`);\n    }\n    const data = await response.json();\n    console.log(`Fichier \"${file.name}\" téléchargé sur IPFS avec succès`);\n    console.log(`Hash IPFS: ${data.Hash}`);\n    return data.Hash;\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS:', error);\n\n    // Solution de secours en cas d'erreur\n    console.warn('Erreur IPFS. Utilisation du stockage local temporaire...');\n\n    // Créer une URL d'objet pour le fichier (solution de secours)\n    const blobUrl = URL.createObjectURL(file);\n\n    // Générer un ID unique pour simuler un hash IPFS\n    const tempId = 'local-' + Math.random().toString(36).substring(2, 15);\n\n    // Stocker l'URL et l'ID dans le sessionStorage\n    sessionStorage.setItem(`ipfs-fallback-${tempId}`, blobUrl);\n    sessionStorage.setItem(`ipfs-fallback-name-${tempId}`, file.name);\n    console.log(`Fichier \"${file.name}\" stocké localement (fallback) avec l'ID: ${tempId}`);\n    return tempId;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur IPFS\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = ipfsHash => {\n  if (!ipfsHash) return '';\n\n  // Vérifier si c'est un hash de secours local\n  if (ipfsHash.startsWith('local-')) {\n    const url = sessionStorage.getItem(`ipfs-fallback-${ipfsHash}`);\n    if (url) {\n      return url;\n    }\n    console.warn(`Fichier local ${ipfsHash} non trouvé`);\n    return '';\n  }\n\n  // Utiliser la passerelle IPFS locale via Docker\n  return `http://localhost:8080/ipfs/${ipfsHash}`;\n};\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};","map":{"version":3,"names":["uploadToIPFS","file","Error","console","log","formData","FormData","append","response","fetch","method","body","ok","status","data","json","name","Hash","error","warn","blobUrl","URL","createObjectURL","tempId","Math","random","toString","substring","sessionStorage","setItem","getIPFSGatewayURL","ipfsHash","startsWith","url","getItem"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["/**\n * Utilitaire pour interagir avec IPFS via Docker\n */\n\n/**\n * Télécharge un fichier sur IPFS en utilisant l'API HTTP directement\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS du fichier téléchargé\n */\nexport const uploadToIPFS = async (file) => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    \n    console.log('Début du téléchargement sur IPFS...');\n    \n    // Créer un objet FormData pour l'envoi du fichier\n    const formData = new FormData();\n    formData.append('file', file);\n    \n    // Utiliser l'API IPFS locale via Docker\n    const response = await fetch('http://localhost:5001/api/v0/add?pin=true', {\n      method: 'POST',\n      body: formData\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Erreur HTTP: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    console.log(`Fichier \"${file.name}\" téléchargé sur IPFS avec succès`);\n    console.log(`Hash IPFS: ${data.Hash}`);\n    \n    return data.Hash;\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS:', error);\n    \n    // Solution de secours en cas d'erreur\n    console.warn('Erreur IPFS. Utilisation du stockage local temporaire...');\n    \n    // Créer une URL d'objet pour le fichier (solution de secours)\n    const blobUrl = URL.createObjectURL(file);\n    \n    // Générer un ID unique pour simuler un hash IPFS\n    const tempId = 'local-' + Math.random().toString(36).substring(2, 15);\n    \n    // Stocker l'URL et l'ID dans le sessionStorage\n    sessionStorage.setItem(`ipfs-fallback-${tempId}`, blobUrl);\n    sessionStorage.setItem(`ipfs-fallback-name-${tempId}`, file.name);\n    \n    console.log(`Fichier \"${file.name}\" stocké localement (fallback) avec l'ID: ${tempId}`);\n    return tempId;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur IPFS\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = (ipfsHash) => {\n  if (!ipfsHash) return '';\n  \n  // Vérifier si c'est un hash de secours local\n  if (ipfsHash.startsWith('local-')) {\n    const url = sessionStorage.getItem(`ipfs-fallback-${ipfsHash}`);\n    if (url) {\n      return url;\n    }\n    console.warn(`Fichier local ${ipfsHash} non trouvé`);\n    return '';\n  }\n  \n  // Utiliser la passerelle IPFS locale via Docker\n  return `http://localhost:8080/ipfs/${ipfsHash}`;\n};\n\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,YAAY,GAAG,MAAOC,IAAI,IAAK;EAC1C,IAAI;IACF;IACA,IAAI,CAACA,IAAI,EAAE;MACT,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;IACzC;IAEAC,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;;IAElD;IACA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;IAC/BD,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAEN,IAAI,CAAC;;IAE7B;IACA,MAAMO,QAAQ,GAAG,MAAMC,KAAK,CAAC,2CAA2C,EAAE;MACxEC,MAAM,EAAE,MAAM;MACdC,IAAI,EAAEN;IACR,CAAC,CAAC;IAEF,IAAI,CAACG,QAAQ,CAACI,EAAE,EAAE;MAChB,MAAM,IAAIV,KAAK,CAAC,gBAAgBM,QAAQ,CAACK,MAAM,EAAE,CAAC;IACpD;IAEA,MAAMC,IAAI,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC;IAClCZ,OAAO,CAACC,GAAG,CAAC,YAAYH,IAAI,CAACe,IAAI,mCAAmC,CAAC;IACrEb,OAAO,CAACC,GAAG,CAAC,cAAcU,IAAI,CAACG,IAAI,EAAE,CAAC;IAEtC,OAAOH,IAAI,CAACG,IAAI;EAClB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdf,OAAO,CAACe,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;;IAE/D;IACAf,OAAO,CAACgB,IAAI,CAAC,0DAA0D,CAAC;;IAExE;IACA,MAAMC,OAAO,GAAGC,GAAG,CAACC,eAAe,CAACrB,IAAI,CAAC;;IAEzC;IACA,MAAMsB,MAAM,GAAG,QAAQ,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC;;IAErE;IACAC,cAAc,CAACC,OAAO,CAAC,iBAAiBN,MAAM,EAAE,EAAEH,OAAO,CAAC;IAC1DQ,cAAc,CAACC,OAAO,CAAC,sBAAsBN,MAAM,EAAE,EAAEtB,IAAI,CAACe,IAAI,CAAC;IAEjEb,OAAO,CAACC,GAAG,CAAC,YAAYH,IAAI,CAACe,IAAI,6CAA6CO,MAAM,EAAE,CAAC;IACvF,OAAOA,MAAM;EACf;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMO,iBAAiB,GAAIC,QAAQ,IAAK;EAC7C,IAAI,CAACA,QAAQ,EAAE,OAAO,EAAE;;EAExB;EACA,IAAIA,QAAQ,CAACC,UAAU,CAAC,QAAQ,CAAC,EAAE;IACjC,MAAMC,GAAG,GAAGL,cAAc,CAACM,OAAO,CAAC,iBAAiBH,QAAQ,EAAE,CAAC;IAC/D,IAAIE,GAAG,EAAE;MACP,OAAOA,GAAG;IACZ;IACA9B,OAAO,CAACgB,IAAI,CAAC,iBAAiBY,QAAQ,aAAa,CAAC;IACpD,OAAO,EAAE;EACX;;EAEA;EACA,OAAO,8BAA8BA,QAAQ,EAAE;AACjD,CAAC;AAED,eAAe;EACb/B,YAAY;EACZ8B;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}