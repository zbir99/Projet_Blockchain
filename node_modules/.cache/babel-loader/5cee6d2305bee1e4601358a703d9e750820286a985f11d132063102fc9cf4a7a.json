{"ast":null,"code":"import { create } from 'ipfs-http-client';\n\n// Configuration du client IPFS pour se connecter au daemon IPFS local\n// avec gestion des erreurs CORS\nlet ipfs;\ntry {\n  // Tentative de création du client avec l'URL complète\n  ipfs = create({\n    url: 'http://localhost:5001/api/v0',\n    headers: {\n      'Access-Control-Allow-Origin': '*'\n    }\n  });\n} catch (error) {\n  console.error('Erreur lors de la création du client IPFS:', error);\n}\n\n/**\n * Télécharge un fichier sur IPFS\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS du fichier téléchargé\n */\nexport const uploadToIPFS = async file => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n\n    // Vérification que le client IPFS est disponible\n    if (!ipfs) {\n      throw new Error('Client IPFS non disponible. Assurez-vous que le daemon IPFS est en cours d\\'exécution avec CORS activé.');\n    }\n\n    // Lecture du fichier\n    const fileBuffer = await file.arrayBuffer();\n\n    // Méthode alternative utilisant fetch directement si ipfs.add échoue\n    try {\n      // Essai avec ipfs-http-client\n      const result = await ipfs.add(new Uint8Array(fileBuffer));\n      return result.path;\n    } catch (ipfsError) {\n      console.warn('Erreur avec ipfs-http-client, tentative avec fetch direct:', ipfsError);\n\n      // Méthode alternative avec fetch\n      const formData = new FormData();\n      formData.append('file', file);\n      const response = await fetch('http://localhost:5001/api/v0/add', {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`Erreur HTTP: ${response.status}`);\n      }\n      const data = await response.json();\n      return data.Hash;\n    }\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS:', error);\n    throw error;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur la passerelle IPFS locale\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = ipfsHash => {\n  if (!ipfsHash) return '';\n  return `http://localhost:8080/ipfs/${ipfsHash}`;\n};\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};","map":{"version":3,"names":["create","ipfs","url","headers","error","console","uploadToIPFS","file","Error","fileBuffer","arrayBuffer","result","add","Uint8Array","path","ipfsError","warn","formData","FormData","append","response","fetch","method","body","ok","status","data","json","Hash","getIPFSGatewayURL","ipfsHash"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["import { create } from 'ipfs-http-client';\n\n// Configuration du client IPFS pour se connecter au daemon IPFS local\n// avec gestion des erreurs CORS\nlet ipfs;\n\ntry {\n  // Tentative de création du client avec l'URL complète\n  ipfs = create({\n    url: 'http://localhost:5001/api/v0',\n    headers: {\n      'Access-Control-Allow-Origin': '*'\n    }\n  });\n} catch (error) {\n  console.error('Erreur lors de la création du client IPFS:', error);\n}\n\n/**\n * Télécharge un fichier sur IPFS\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS du fichier téléchargé\n */\nexport const uploadToIPFS = async (file) => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    \n    // Vérification que le client IPFS est disponible\n    if (!ipfs) {\n      throw new Error('Client IPFS non disponible. Assurez-vous que le daemon IPFS est en cours d\\'exécution avec CORS activé.');\n    }\n    \n    // Lecture du fichier\n    const fileBuffer = await file.arrayBuffer();\n    \n    // Méthode alternative utilisant fetch directement si ipfs.add échoue\n    try {\n      // Essai avec ipfs-http-client\n      const result = await ipfs.add(new Uint8Array(fileBuffer));\n      return result.path;\n    } catch (ipfsError) {\n      console.warn('Erreur avec ipfs-http-client, tentative avec fetch direct:', ipfsError);\n      \n      // Méthode alternative avec fetch\n      const formData = new FormData();\n      formData.append('file', file);\n      \n      const response = await fetch('http://localhost:5001/api/v0/add', {\n        method: 'POST',\n        body: formData,\n        headers: {\n          'Accept': 'application/json'\n        }\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Erreur HTTP: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      return data.Hash;\n    }\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS:', error);\n    throw error;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur la passerelle IPFS locale\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = (ipfsHash) => {\n  if (!ipfsHash) return '';\n  return `http://localhost:8080/ipfs/${ipfsHash}`;\n};\n\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,kBAAkB;;AAEzC;AACA;AACA,IAAIC,IAAI;AAER,IAAI;EACF;EACAA,IAAI,GAAGD,MAAM,CAAC;IACZE,GAAG,EAAE,8BAA8B;IACnCC,OAAO,EAAE;MACP,6BAA6B,EAAE;IACjC;EACF,CAAC,CAAC;AACJ,CAAC,CAAC,OAAOC,KAAK,EAAE;EACdC,OAAO,CAACD,KAAK,CAAC,4CAA4C,EAAEA,KAAK,CAAC;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAME,YAAY,GAAG,MAAOC,IAAI,IAAK;EAC1C,IAAI;IACF;IACA,IAAI,CAACA,IAAI,EAAE;MACT,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;IACzC;;IAEA;IACA,IAAI,CAACP,IAAI,EAAE;MACT,MAAM,IAAIO,KAAK,CAAC,yGAAyG,CAAC;IAC5H;;IAEA;IACA,MAAMC,UAAU,GAAG,MAAMF,IAAI,CAACG,WAAW,CAAC,CAAC;;IAE3C;IACA,IAAI;MACF;MACA,MAAMC,MAAM,GAAG,MAAMV,IAAI,CAACW,GAAG,CAAC,IAAIC,UAAU,CAACJ,UAAU,CAAC,CAAC;MACzD,OAAOE,MAAM,CAACG,IAAI;IACpB,CAAC,CAAC,OAAOC,SAAS,EAAE;MAClBV,OAAO,CAACW,IAAI,CAAC,4DAA4D,EAAED,SAAS,CAAC;;MAErF;MACA,MAAME,QAAQ,GAAG,IAAIC,QAAQ,CAAC,CAAC;MAC/BD,QAAQ,CAACE,MAAM,CAAC,MAAM,EAAEZ,IAAI,CAAC;MAE7B,MAAMa,QAAQ,GAAG,MAAMC,KAAK,CAAC,kCAAkC,EAAE;QAC/DC,MAAM,EAAE,MAAM;QACdC,IAAI,EAAEN,QAAQ;QACdd,OAAO,EAAE;UACP,QAAQ,EAAE;QACZ;MACF,CAAC,CAAC;MAEF,IAAI,CAACiB,QAAQ,CAACI,EAAE,EAAE;QAChB,MAAM,IAAIhB,KAAK,CAAC,gBAAgBY,QAAQ,CAACK,MAAM,EAAE,CAAC;MACpD;MAEA,MAAMC,IAAI,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC;MAClC,OAAOD,IAAI,CAACE,IAAI;IAClB;EACF,CAAC,CAAC,OAAOxB,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;IAC/D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMyB,iBAAiB,GAAIC,QAAQ,IAAK;EAC7C,IAAI,CAACA,QAAQ,EAAE,OAAO,EAAE;EACxB,OAAO,8BAA8BA,QAAQ,EAAE;AACjD,CAAC;AAED,eAAe;EACbxB,YAAY;EACZuB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}