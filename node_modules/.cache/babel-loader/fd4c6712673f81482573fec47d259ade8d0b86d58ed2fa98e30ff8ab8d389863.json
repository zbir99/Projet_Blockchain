{"ast":null,"code":"/**\n * Utilitaire pour interagir avec IPFS\n */\nimport { create } from 'ipfs-http-client';\n\n/**\n * Créer une instance du client IPFS\n * Utilise Infura comme service IPFS public qui gère bien CORS\n */\nconst projectId = '';\nconst projectSecret = '';\nconst auth = projectId && projectSecret ? 'Basic ' + Buffer.from(projectId + ':' + projectSecret).toString('base64') : '';\n\n// Utiliser une passerelle publique qui fonctionne bien avec CORS\nconst ipfs = create({\n  host: 'ipfs.infura.io',\n  port: 5001,\n  protocol: 'https',\n  headers: {\n    authorization: auth\n  }\n});\n\n/**\n * Télécharge un fichier sur IPFS\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS du fichier téléchargé\n */\nexport const uploadToIPFS = async file => {\n  // Vérification que le fichier est valide\n  if (!file) {\n    throw new Error('Aucun fichier fourni');\n  }\n  console.log('Début du téléchargement sur IPFS...');\n\n  // Lire le fichier sous forme de tableau d'octets\n  const buffer = await file.arrayBuffer();\n  const fileContent = new Uint8Array(buffer);\n\n  // Télécharger le fichier sur IPFS en utilisant ipfs-http-client\n  const result = await ipfs.add({\n    path: file.name,\n    content: fileContent\n  }, {\n    pin: true\n  });\n  console.log(`Fichier \"${file.name}\" téléchargé sur IPFS avec succès`);\n  console.log(`Hash IPFS: ${result.cid}`);\n  return result.cid.toString();\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur IPFS\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = ipfsHash => {\n  if (!ipfsHash) return '';\n\n  // Utiliser une passerelle IPFS publique pour éviter les problèmes CORS\n  return `https://ipfs.io/ipfs/${ipfsHash}`;\n};\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};","map":{"version":3,"names":["create","projectId","projectSecret","auth","Buffer","from","toString","ipfs","host","port","protocol","headers","authorization","uploadToIPFS","file","Error","console","log","buffer","arrayBuffer","fileContent","Uint8Array","result","add","path","name","content","pin","cid","getIPFSGatewayURL","ipfsHash"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["/**\n * Utilitaire pour interagir avec IPFS\n */\nimport { create } from 'ipfs-http-client';\n\n/**\n * Créer une instance du client IPFS\n * Utilise Infura comme service IPFS public qui gère bien CORS\n */\nconst projectId = '';\nconst projectSecret = '';\nconst auth = projectId && projectSecret ? 'Basic ' + Buffer.from(projectId + ':' + projectSecret).toString('base64') : '';\n\n// Utiliser une passerelle publique qui fonctionne bien avec CORS\nconst ipfs = create({\n  host: 'ipfs.infura.io',\n  port: 5001,\n  protocol: 'https',\n  headers: {\n    authorization: auth\n  }\n});\n\n/**\n * Télécharge un fichier sur IPFS\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS du fichier téléchargé\n */\nexport const uploadToIPFS = async (file) => {\n  // Vérification que le fichier est valide\n  if (!file) {\n    throw new Error('Aucun fichier fourni');\n  }\n  \n  console.log('Début du téléchargement sur IPFS...');\n  \n  // Lire le fichier sous forme de tableau d'octets\n  const buffer = await file.arrayBuffer();\n  const fileContent = new Uint8Array(buffer);\n  \n  // Télécharger le fichier sur IPFS en utilisant ipfs-http-client\n  const result = await ipfs.add(\n    { path: file.name, content: fileContent },\n    { pin: true }\n  );\n  \n  console.log(`Fichier \"${file.name}\" téléchargé sur IPFS avec succès`);\n  console.log(`Hash IPFS: ${result.cid}`);\n  \n  return result.cid.toString();\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur IPFS\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = (ipfsHash) => {\n  if (!ipfsHash) return '';\n  \n  // Utiliser une passerelle IPFS publique pour éviter les problèmes CORS\n  return `https://ipfs.io/ipfs/${ipfsHash}`;\n};\n\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,kBAAkB;;AAEzC;AACA;AACA;AACA;AACA,MAAMC,SAAS,GAAG,EAAE;AACpB,MAAMC,aAAa,GAAG,EAAE;AACxB,MAAMC,IAAI,GAAGF,SAAS,IAAIC,aAAa,GAAG,QAAQ,GAAGE,MAAM,CAACC,IAAI,CAACJ,SAAS,GAAG,GAAG,GAAGC,aAAa,CAAC,CAACI,QAAQ,CAAC,QAAQ,CAAC,GAAG,EAAE;;AAEzH;AACA,MAAMC,IAAI,GAAGP,MAAM,CAAC;EAClBQ,IAAI,EAAE,gBAAgB;EACtBC,IAAI,EAAE,IAAI;EACVC,QAAQ,EAAE,OAAO;EACjBC,OAAO,EAAE;IACPC,aAAa,EAAET;EACjB;AACF,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMU,YAAY,GAAG,MAAOC,IAAI,IAAK;EAC1C;EACA,IAAI,CAACA,IAAI,EAAE;IACT,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;EACzC;EAEAC,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;;EAElD;EACA,MAAMC,MAAM,GAAG,MAAMJ,IAAI,CAACK,WAAW,CAAC,CAAC;EACvC,MAAMC,WAAW,GAAG,IAAIC,UAAU,CAACH,MAAM,CAAC;;EAE1C;EACA,MAAMI,MAAM,GAAG,MAAMf,IAAI,CAACgB,GAAG,CAC3B;IAAEC,IAAI,EAAEV,IAAI,CAACW,IAAI;IAAEC,OAAO,EAAEN;EAAY,CAAC,EACzC;IAAEO,GAAG,EAAE;EAAK,CACd,CAAC;EAEDX,OAAO,CAACC,GAAG,CAAC,YAAYH,IAAI,CAACW,IAAI,mCAAmC,CAAC;EACrET,OAAO,CAACC,GAAG,CAAC,cAAcK,MAAM,CAACM,GAAG,EAAE,CAAC;EAEvC,OAAON,MAAM,CAACM,GAAG,CAACtB,QAAQ,CAAC,CAAC;AAC9B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMuB,iBAAiB,GAAIC,QAAQ,IAAK;EAC7C,IAAI,CAACA,QAAQ,EAAE,OAAO,EAAE;;EAExB;EACA,OAAO,wBAAwBA,QAAQ,EAAE;AAC3C,CAAC;AAED,eAAe;EACbjB,YAAY;EACZgB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}