{"ast":null,"code":"function decode_arithmetic(bytes) {\n  let pos = 0;\n  function u16() {\n    return bytes[pos++] << 8 | bytes[pos++];\n  }\n\n  // decode the frequency table\n  let symbol_count = u16();\n  let total = 1;\n  let acc = [0, 1]; // first symbol has frequency 1\n  for (let i = 1; i < symbol_count; i++) {\n    acc.push(total += u16());\n  }\n\n  // skip the sized-payload that the last 3 symbols index into\n  let skip = u16();\n  let pos_payload = pos;\n  pos += skip;\n  let read_width = 0;\n  let read_buffer = 0;\n  function read_bit() {\n    if (read_width == 0) {\n      // this will read beyond end of buffer\n      // but (undefined|0) => zero pad\n      read_buffer = read_buffer << 8 | bytes[pos++];\n      read_width = 8;\n    }\n    return read_buffer >> --read_width & 1;\n  }\n  const N = 31;\n  const FULL = 2 ** N;\n  const HALF = FULL >>> 1;\n  const QRTR = HALF >> 1;\n  const MASK = FULL - 1;\n\n  // fill register\n  let register = 0;\n  for (let i = 0; i < N; i++) register = register << 1 | read_bit();\n  let symbols = [];\n  let low = 0;\n  let range = FULL; // treat like a float\n  while (true) {\n    let value = Math.floor(((register - low + 1) * total - 1) / range);\n    let start = 0;\n    let end = symbol_count;\n    while (end - start > 1) {\n      // binary search\n      let mid = start + end >>> 1;\n      if (value < acc[mid]) {\n        end = mid;\n      } else {\n        start = mid;\n      }\n    }\n    if (start == 0) break; // first symbol is end mark\n    symbols.push(start);\n    let a = low + Math.floor(range * acc[start] / total);\n    let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n    while (((a ^ b) & HALF) == 0) {\n      register = register << 1 & MASK | read_bit();\n      a = a << 1 & MASK;\n      b = b << 1 & MASK | 1;\n    }\n    while (a & ~b & QRTR) {\n      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();\n      a = a << 1 ^ HALF;\n      b = (b ^ HALF) << 1 | HALF | 1;\n    }\n    low = a;\n    range = 1 + b - a;\n  }\n  let offset = symbol_count - 4;\n  return symbols.map(x => {\n    // index into payload\n    switch (x - offset) {\n      case 3:\n        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 2:\n        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);\n      case 1:\n        return offset + bytes[pos_payload++];\n      default:\n        return x - 1;\n    }\n  });\n}\n\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n  let pos = 0;\n  return () => v[pos++];\n}\nfunction read_compressed_payload(s) {\n  return read_payload(decode_arithmetic(unsafe_atob(s)));\n}\n\n// unsafe in the sense:\n// expected well-formed Base64 w/o padding \nfunction unsafe_atob(s) {\n  let lookup = [];\n  [...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\n  let n = s.length;\n  let ret = new Uint8Array(6 * n >> 3);\n  for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\n    carry = carry << 6 | lookup[s.charCodeAt(i)];\n    width += 6;\n    if (width >= 8) {\n      ret[pos++] = carry >> (width -= 8);\n    }\n  }\n  return ret;\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n  return i & 1 ? ~i >> 1 : i >> 1;\n}\nfunction read_deltas(n, next) {\n  let v = Array(n);\n  for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n  return v;\n}\n\n// [123][5] => [0 3] [1 1] [0 0]\nfunction read_sorted(next, prev = 0) {\n  let ret = [];\n  while (true) {\n    let x = next();\n    let n = next();\n    if (!n) break;\n    prev += x;\n    for (let i = 0; i < n; i++) {\n      ret.push(prev + i);\n    }\n    prev += n + 1;\n  }\n  return ret;\n}\nfunction read_sorted_arrays(next) {\n  return read_array_while(() => {\n    let v = read_sorted(next);\n    if (v.length) return v;\n  });\n}\n\n// returns map of x => ys\nfunction read_mapped(next) {\n  let ret = [];\n  while (true) {\n    let w = next();\n    if (w == 0) break;\n    ret.push(read_linear_table(w, next));\n  }\n  while (true) {\n    let w = next() - 1;\n    if (w < 0) break;\n    ret.push(read_replacement_table(w, next));\n  }\n  return ret.flat();\n}\n\n// read until next is falsy\n// return array of read values\nfunction read_array_while(next) {\n  let v = [];\n  while (true) {\n    let x = next(v.length);\n    if (!x) break;\n    v.push(x);\n  }\n  return v;\n}\n\n// read w columns of length n\n// return as n rows of length w\nfunction read_transposed(n, w, next) {\n  let m = Array(n).fill().map(() => []);\n  for (let i = 0; i < w; i++) {\n    read_deltas(n, next).forEach((x, j) => m[j].push(x));\n  }\n  return m;\n}\n\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\n// where dx/dy = steps, n = run size, w = length of y\nfunction read_linear_table(w, next) {\n  let dx = 1 + next();\n  let dy = next();\n  let vN = read_array_while(next);\n  let m = read_transposed(vN.length, 1 + w, next);\n  return m.flatMap((v, i) => {\n    let [x, ...ys] = v;\n    return Array(vN[i]).fill().map((_, j) => {\n      let j_dy = j * dy;\n      return [x + j * dx, ys.map(y => y + j_dy)];\n    });\n  });\n}\n\n// return [[x, ys...], ...]\n// where w = length of y\nfunction read_replacement_table(w, next) {\n  let n = 1 + next();\n  let m = read_transposed(n, 1 + w, next);\n  return m.map(v => [v[0], v.slice(1)]);\n}\n\n// created 2023-01-26T08:54:35.886Z\nvar r = read_compressed_payload('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');\nconst FENCED = new Map([[8217, \"apostrophe\"], [8260, \"fraction slash\"], [12539, \"middle dot\"]]);\nfunction hex_cp(cp) {\n  return cp.toString(16).toUpperCase().padStart(2, '0');\n}\nfunction quote_cp(cp) {\n  return `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\n}\n\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\nfunction explode_cp(s) {\n  // this is about 2x faster\n  let cps = [];\n  for (let pos = 0, len = s.length; pos < len;) {\n    let cp = s.codePointAt(pos);\n    pos += cp < 0x10000 ? 1 : 2;\n    cps.push(cp);\n  }\n  return cps;\n}\nfunction str_from_cps(cps) {\n  const chunk = 4096;\n  let len = cps.length;\n  if (len < chunk) return String.fromCodePoint(...cps);\n  let buf = [];\n  for (let i = 0; i < len;) {\n    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\n  }\n  return buf.join('');\n}\nfunction compare_arrays(a, b) {\n  let n = a.length;\n  let c = n - b.length;\n  for (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\n  return c;\n}\n\n// reverse polyfill\n\nfunction nf(cps, form) {\n  return explode_cp(str_from_cps(cps).normalize(form));\n}\nfunction nfc(cps) {\n  return nf(cps, 'NFC');\n}\nfunction nfd(cps) {\n  return nf(cps, 'NFD');\n}\n\n//const t0 = performance.now();\n\nconst STOP = 0x2E;\nconst FE0F = 0xFE0F;\nconst STOP_CH = '.';\nconst UNIQUE_PH = 1;\nconst HYPHEN = 0x2D;\nfunction read_set() {\n  return new Set(read_sorted(r));\n}\nconst MAPPED = new Map(read_mapped(r));\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\nconst CM = read_set();\nconst ESCAPE = read_set(); // characters that should not be printed\nconst NFC_CHECK = read_set();\nconst CHUNKS = read_sorted_arrays(r);\nfunction read_chunked() {\n  // deduplicated sets + uniques\n  return new Set([read_sorted(r).map(i => CHUNKS[i]), read_sorted(r)].flat(2));\n}\nconst UNRESTRICTED = r();\nconst GROUPS = read_array_while(i => {\n  // minifier property mangling seems unsafe\n  // so these are manually renamed to single chars\n  let N = read_array_while(r).map(x => x + 0x60);\n  if (N.length) {\n    let R = i >= UNRESTRICTED; // first arent restricted\n    N[0] -= 32; // capitalize\n    N = str_from_cps(N);\n    if (R) N = `Restricted[${N}]`;\n    let P = read_chunked(); // primary\n    let Q = read_chunked(); // secondary\n    let V = [...P, ...Q].sort((a, b) => a - b); // derive: sorted valid\n    let M = r() - 1; // combining mark\n    // code currently isn't needed\n    /*if (M < 0) { // whitelisted\r\n    \tM = new Map(read_array_while(() => {\r\n    \t\tlet i = r();\r\n    \t\tif (i) return [V[i-1], read_array_while(() => {\r\n    \t\t\tlet v = read_array_while(r);\r\n    \t\t\tif (v.length) return v.map(x => x-1);\r\n    \t\t})];\r\n    \t}));\r\n    }*/\n    return {\n      N,\n      P,\n      M,\n      R,\n      V: new Set(V)\n    };\n  }\n});\nconst WHOLE_VALID = read_set();\nconst WHOLE_MAP = new Map();\n// decode compressed wholes\n[...WHOLE_VALID, ...read_set()].sort((a, b) => a - b).map((cp, i, v) => {\n  let d = r();\n  let w = v[i] = d ? v[i - d] : {\n    V: [],\n    M: new Map()\n  };\n  w.V.push(cp); // add to member set\n  if (!WHOLE_VALID.has(cp)) {\n    WHOLE_MAP.set(cp, w); // register with whole map\n  }\n});\n// compute confusable-extent complements\nfor (let {\n  V,\n  M\n} of new Set(WHOLE_MAP.values())) {\n  // connect all groups that have each whole character\n  let recs = [];\n  for (let cp of V) {\n    let gs = GROUPS.filter(g => g.V.has(cp));\n    let rec = recs.find(({\n      G\n    }) => gs.some(g => G.has(g)));\n    if (!rec) {\n      rec = {\n        G: new Set(),\n        V: []\n      };\n      recs.push(rec);\n    }\n    rec.V.push(cp);\n    gs.forEach(g => rec.G.add(g));\n  }\n  // per character cache groups which are not a member of the extent\n  let union = recs.flatMap(({\n    G\n  }) => [...G]);\n  for (let {\n    G,\n    V\n  } of recs) {\n    let complement = new Set(union.filter(g => !G.has(g)));\n    for (let cp of V) {\n      M.set(cp, complement);\n    }\n  }\n}\nlet union = new Set(); // exists in 1+ groups\nlet multi = new Set(); // exists in 2+ groups\nfor (let g of GROUPS) {\n  for (let cp of g.V) {\n    (union.has(cp) ? multi : union).add(cp);\n  }\n}\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\nfor (let cp of union) {\n  if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\n    WHOLE_MAP.set(cp, UNIQUE_PH);\n  }\n}\nconst VALID = new Set([...union, ...nfd(union)]); // possibly valid\n\n// decode emoji\nconst EMOJI_SORTED = read_sorted(r);\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\nconst EMOJI_ROOT = read_emoji_trie([]);\nfunction read_emoji_trie(cps) {\n  let B = read_array_while(() => {\n    let keys = read_sorted(r).map(i => EMOJI_SORTED[i]);\n    if (keys.length) return read_emoji_trie(keys);\n  }).sort((a, b) => b.Q.size - a.Q.size); // sort by likelihood\n  let temp = r();\n  let V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\n  temp = temp / 3 | 0;\n  let F = temp & 1; // allow FE0F\n  temp >>= 1;\n  let S = temp & 1; // save\n  let C = temp & 2; // check\n  return {\n    B,\n    V,\n    F,\n    S,\n    C,\n    Q: new Set(cps)\n  };\n}\n//console.log(performance.now() - t0);\n\n// free tagging system\nclass Emoji extends Array {\n  get is_emoji() {\n    return true;\n  }\n}\n\n// create a safe to print string \n// invisibles are escaped\n// leading cm uses placeholder\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\n  //if (Number.isInteger(cps)) cps = [cps];\n  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\n  let buf = [];\n  if (is_combining_mark(cps[0])) buf.push('◌');\n  let prev = 0;\n  let n = cps.length;\n  for (let i = 0; i < n; i++) {\n    let cp = cps[i];\n    if (should_escape(cp)) {\n      buf.push(str_from_cps(cps.slice(prev, i)));\n      buf.push(quoter(cp));\n      prev = i + 1;\n    }\n  }\n  buf.push(str_from_cps(cps.slice(prev, n)));\n  return buf.join('');\n}\n\n// if escaped: {HEX}\n//       else: \"x\" {HEX}\nfunction quoted_cp(cp) {\n  return (should_escape(cp) ? '' : `\"${safe_str_from_cps([cp])}\" `) + quote_cp(cp);\n}\nfunction check_label_extension(cps) {\n  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\n    throw new Error('invalid label extension');\n  }\n}\nfunction check_leading_underscore(cps) {\n  const UNDERSCORE = 0x5F;\n  for (let i = cps.lastIndexOf(UNDERSCORE); i > 0;) {\n    if (cps[--i] !== UNDERSCORE) {\n      throw new Error('underscore allowed only at start');\n    }\n  }\n}\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\nfunction check_fenced(cps) {\n  let cp = cps[0];\n  let prev = FENCED.get(cp);\n  if (prev) throw error_placement(`leading ${prev}`);\n  let n = cps.length;\n  let last = -1;\n  for (let i = 1; i < n; i++) {\n    cp = cps[i];\n    let match = FENCED.get(cp);\n    if (match) {\n      if (last == i) throw error_placement(`${prev} + ${match}`);\n      last = i + 1;\n      prev = match;\n    }\n  }\n  if (last == n) throw error_placement(`trailing ${prev}`);\n}\n\n// note: set(s) cannot be exposed because they can be modified\nfunction is_combining_mark(cp) {\n  return CM.has(cp);\n}\nfunction should_escape(cp) {\n  return ESCAPE.has(cp);\n}\nfunction ens_normalize_fragment(frag, decompose) {\n  let nf = decompose ? nfd : nfc;\n  return frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf).flatMap(x => x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);\n}\nfunction ens_normalize(name) {\n  return flatten(ens_split(name));\n}\nfunction ens_beautify(name) {\n  let split = ens_split(name, true);\n  // this is experimental\n  for (let {\n    type,\n    output,\n    error\n  } of split) {\n    if (error) continue;\n\n    // replace leading/trailing hyphen\n    // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\n    // not exactly the same in every font, but very similar: \"-\" vs \"‐\"\n    /*\r\n    const UNICODE_HYPHEN = 0x2010;\r\n    // maybe this should replace all for visual consistancy?\r\n    // `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n    //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n    if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n    let end = output.length-1;\r\n    if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n    */\n    // 20230123: WHATWG URL uses \"CheckHyphens\" false\n    // https://url.spec.whatwg.org/#idna\n\n    // ξ => Ξ if not greek\n    if (type !== 'Greek') {\n      let prev = 0;\n      while (true) {\n        let next = output.indexOf(0x3BE, prev);\n        if (next < 0) break;\n        output[next] = 0x39E;\n        prev = next + 1;\n      }\n    }\n\n    // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\n    // could be fixed with special case for: 2D (.) + 200E (LTR)\n    //output.splice(0, 0, 0x200E);\n  }\n  return flatten(split);\n}\nfunction ens_split(name, preserve_emoji) {\n  let offset = 0;\n  // https://unicode.org/reports/tr46/#Validity_Criteria 4.1 Rule 4\n  // \"The label must not contain a U+002E ( . ) FULL STOP.\"\n  return name.split(STOP_CH).map(label => {\n    let input = explode_cp(label);\n    let info = {\n      input,\n      offset // codepoint, not substring!\n    };\n    offset += input.length + 1; // + stop\n    let norm;\n    try {\n      let tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\n      let token_count = tokens.length;\n      let type;\n      if (!token_count) {\n        // the label was effectively empty (could of had ignored characters)\n        // 20230120: change to strict\n        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\n        //norm = [];\n        //type = 'None'; // use this instead of next match, \"ASCII\"\n        throw new Error(`empty label`);\n      } else {\n        let chars = tokens[0];\n        let emoji = token_count > 1 || chars.is_emoji;\n        if (!emoji && chars.every(cp => cp < 0x80)) {\n          // special case for ascii\n          norm = chars;\n          check_leading_underscore(norm);\n          // only needed for ascii\n          // 20230123: matches matches WHATWG, see note 3.3\n          check_label_extension(norm);\n          // cant have fenced\n          // cant have cm\n          // cant have wholes\n          // see derive: assert ascii fast path\n          type = 'ASCII';\n        } else {\n          if (emoji) {\n            // there is at least one emoji\n            info.emoji = true;\n            chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\n          }\n          norm = tokens.flatMap(x => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);\n          check_leading_underscore(norm);\n          if (!chars.length) {\n            // theres no text, just emoji\n            type = 'Emoji';\n          } else {\n            if (CM.has(norm[0])) throw error_placement('leading combining mark');\n            for (let i = 1; i < token_count; i++) {\n              // we've already checked the first token\n              let cps = tokens[i];\n              if (!cps.is_emoji && CM.has(cps[0])) {\n                // every text token has emoji neighbors, eg. EtEEEtEt...\n                throw error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}\"`);\n              }\n            }\n            check_fenced(norm);\n            let unique = [...new Set(chars)];\n            let [g] = determine_group(unique); // take the first match\n            // see derive: \"Matching Groups have Same CM Style\"\n            // alternative: could form a hybrid type: Latin/Japanese/...\t\n            check_group(g, chars); // need text in order\n            check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\n            type = g.N;\n            // 20230121: consider exposing restricted flag\n            // it's simpler to just check for 'Restricted'\n            // or even better: type.endsWith(']')\n            //if (g.R) info.restricted = true;\n          }\n        }\n      }\n      info.type = type;\n    } catch (err) {\n      info.error = err; // use full error object\n    }\n    info.output = norm;\n    return info;\n  });\n}\nfunction check_whole(group, unique) {\n  let maker;\n  let shared = []; // TODO: can this be avoided?\n  for (let cp of unique) {\n    let whole = WHOLE_MAP.get(cp);\n    if (whole === UNIQUE_PH) return; // unique, non-confusable\n    if (whole) {\n      let set = whole.M.get(cp); // groups which have a character that look-like this character\n      maker = maker ? maker.filter(g => set.has(g)) : [...set];\n      if (!maker.length) return; // confusable intersection is empty\n    } else {\n      shared.push(cp);\n    }\n  }\n  if (maker) {\n    // we have 1+ confusable\n    // check if any of the remaning groups\n    // contain the shared characters too\n    for (let g of maker) {\n      if (shared.every(cp => g.V.has(cp))) {\n        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);\n      }\n    }\n  }\n}\n\n// assumption: unique.size > 0\n// returns list of matching groups\nfunction determine_group(unique) {\n  let groups = GROUPS;\n  for (let cp of unique) {\n    // note: we need to dodge CM that are whitelisted\n    // but that code isn't currently necessary\n    let gs = groups.filter(g => g.V.has(cp));\n    if (!gs.length) {\n      if (groups === GROUPS) {\n        // the character was composed of valid parts\n        // but it's NFC form is invalid\n        throw error_disallowed(cp); // this should be rare\n      } else {\n        // there is no group that contains all these characters\n        // throw using the highest priority group that matched\n        // https://www.unicode.org/reports/tr39/#mixed_script_confusables\n        throw error_group_member(groups[0], cp);\n      }\n    }\n    groups = gs;\n    if (gs.length == 1) break; // there is only one group left\n  }\n  // there are at least 1 group(s) with all of these characters\n  return groups;\n}\n\n// throw on first error\nfunction flatten(split) {\n  return split.map(({\n    input,\n    error,\n    output\n  }) => {\n    if (error) {\n      // don't print label again if just a single label\n      let msg = error.message;\n      throw new Error(split.length == 1 ? msg : `Invalid label \"${safe_str_from_cps(input)}\": ${msg}`);\n    }\n    return str_from_cps(output);\n  }).join(STOP_CH);\n}\nfunction error_disallowed(cp) {\n  // TODO: add cp to error?\n  return new Error(`disallowed character: ${quoted_cp(cp)}`);\n}\nfunction error_group_member(g, cp) {\n  let quoted = quoted_cp(cp);\n  let gg = GROUPS.find(g => g.P.has(cp));\n  if (gg) {\n    quoted = `${gg.N} ${quoted}`;\n  }\n  return new Error(`illegal mixture: ${g.N} + ${quoted}`);\n}\nfunction error_placement(where) {\n  return new Error(`illegal placement: ${where}`);\n}\n\n// assumption: cps.length > 0\n// assumption: cps[0] isn't a CM\nfunction check_group(g, cps) {\n  let {\n    V,\n    M\n  } = g;\n  for (let cp of cps) {\n    if (!V.has(cp)) {\n      throw error_group_member(g, cp);\n    }\n  }\n  if (M >= 0) {\n    // we know it can't be cm leading\n    // we know the previous character isn't an emoji\n    let decomposed = nfd(cps);\n    for (let i = 1, e = decomposed.length; i < e; i++) {\n      if (CM.has(cps[i])) {\n        let j = i + 1;\n        while (j < e && CM.has(cps[j])) j++;\n        if (j - i > M) {\n          throw new Error(`too many combining marks: ${g.N} \"${str_from_cps(cps.slice(i - 1, j))}\" (${j - i}/${M})`);\n        }\n        i = j;\n      }\n    }\n  }\n  // *** this code currently isn't needed ***\n  /*\r\n  let cm_whitelist = M instanceof Map;\r\n  for (let i = 0, e = cps.length; i < e; ) {\r\n  \tlet cp = cps[i++];\r\n  \tlet seqs = cm_whitelist && M.get(cp);\r\n  \tif (seqs) { \r\n  \t\t// list of codepoints that can follow\r\n  \t\t// if this exists, this will always be 1+\r\n  \t\tlet j = i;\r\n  \t\twhile (j < e && CM.has(cps[j])) j++;\r\n  \t\tlet cms = cps.slice(i, j);\r\n  \t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n  \t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n  \t\ti = j;\r\n  \t} else if (!V.has(cp)) {\r\n  \t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n  \t\tlet quoted = quoted_cp(cp);\r\n  \t\tfor (let cp of cps) {\r\n  \t\t\tlet u = UNIQUE.get(cp);\r\n  \t\t\tif (u && u !== g) {\r\n  \t\t\t\t// if both scripts are restricted this error is confusing\r\n  \t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n  \t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n  \t\t\t\tbreak;\r\n  \t\t\t}\r\n  \t\t}\r\n  \t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n  \t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n  \t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n  \t}\r\n  }\r\n  if (!cm_whitelist) {\r\n  \tlet decomposed = nfd(cps);\r\n  \tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n  \t\tif (CM.has(cps[i])) {\r\n  \t\t\tlet j = i + 1;\r\n  \t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n  \t\t\tif (j - i > M) {\r\n  \t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(cps.slice(i-1, j))}\" (${j-i}/${M})`);\r\n  \t\t\t}\r\n  \t\t\ti = j;\r\n  \t\t}\r\n  \t}\r\n  }\r\n  */\n}\n\n// given a list of codepoints\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\nfunction process(input, nf) {\n  let ret = [];\n  let chars = [];\n  input = input.slice().reverse(); // flip so we can pop\n  while (input.length) {\n    let emoji = consume_emoji_reversed(input);\n    if (emoji) {\n      if (chars.length) {\n        ret.push(nf(chars));\n        chars = [];\n      }\n      ret.push(emoji);\n    } else {\n      let cp = input.pop();\n      if (VALID.has(cp)) {\n        chars.push(cp);\n      } else {\n        let cps = MAPPED.get(cp);\n        if (cps) {\n          chars.push(...cps);\n        } else if (!IGNORED.has(cp)) {\n          throw error_disallowed(cp);\n        }\n      }\n    }\n  }\n  if (chars.length) {\n    ret.push(nf(chars));\n  }\n  return ret;\n}\nfunction filter_fe0f(cps) {\n  return cps.filter(cp => cp != FE0F);\n}\n\n// given array of codepoints\n// returns the longest valid emoji sequence (or undefined if no match)\n// *MUTATES* the supplied array\n// allows optional FE0F\n// disallows interleaved ignored characters\n// fills (optional) eaten array with matched codepoints\nfunction consume_emoji_reversed(cps, eaten) {\n  let node = EMOJI_ROOT;\n  let emoji;\n  let saved;\n  let stack = [];\n  let pos = cps.length;\n  if (eaten) eaten.length = 0; // clear input buffer (if needed)\n  while (pos) {\n    let cp = cps[--pos];\n    node = node.B.find(x => x.Q.has(cp));\n    if (!node) break;\n    if (node.S) {\n      // remember\n      saved = cp;\n    } else if (node.C) {\n      // check exclusion\n      if (cp === saved) break;\n    }\n    stack.push(cp);\n    if (node.F) {\n      stack.push(FE0F);\n      if (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\n    }\n    if (node.V) {\n      // this is a valid emoji (so far)\n      emoji = conform_emoji_copy(stack, node);\n      if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n      cps.length = pos; // truncate\n    }\n  }\n  /*\r\n  // *** this code currently isn't needed ***\r\n  if (!emoji) {\r\n  \tlet cp = cps[cps.length-1];\r\n  \tif (EMOJI_SOLO.has(cp)) {\r\n  \t\tif (eaten) eaten.push(cp);\r\n  \t\temoji = Emoji.of(cp);\r\n  \t\tcps.pop();\r\n  \t}\r\n  }\r\n  */\n  return emoji;\n}\n\n// create a copy and fix any unicode quirks\nfunction conform_emoji_copy(cps, node) {\n  let copy = Emoji.from(cps); // copy stack\n  if (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\n  return copy;\n}\n\n// return all supported emoji as fully-qualified emoji \n// ordered by length then lexicographic \nfunction ens_emoji() {\n  // *** this code currently isn't needed ***\n  //let ret = [...EMOJI_SOLO].map(x => [x]);\n  let ret = [];\n  build(EMOJI_ROOT, []);\n  return ret.sort(compare_arrays);\n  function build(node, cps, saved) {\n    if (node.S) {\n      saved = cps[cps.length - 1];\n    } else if (node.C) {\n      if (saved === cps[cps.length - 1]) return;\n    }\n    if (node.F) cps.push(FE0F);\n    if (node.V) ret.push(conform_emoji_copy(cps, node));\n    for (let br of node.B) {\n      for (let cp of br.Q) {\n        build(br, [...cps, cp], saved);\n      }\n    }\n  }\n}\n\n// ************************************************************\n// tokenizer \n\nconst TY_VALID = 'valid';\nconst TY_MAPPED = 'mapped';\nconst TY_IGNORED = 'ignored';\nconst TY_DISALLOWED = 'disallowed';\nconst TY_EMOJI = 'emoji';\nconst TY_NFC = 'nfc';\nconst TY_STOP = 'stop';\nfunction ens_tokenize(name, {\n  nf = true // collapse unnormalized runs into a single token\n} = {}) {\n  let input = explode_cp(name).reverse();\n  let eaten = [];\n  let tokens = [];\n  while (input.length) {\n    let emoji = consume_emoji_reversed(input, eaten);\n    if (emoji) {\n      tokens.push({\n        type: TY_EMOJI,\n        emoji,\n        input: eaten.slice(),\n        cps: filter_fe0f(emoji)\n      });\n    } else {\n      let cp = input.pop();\n      if (cp == STOP) {\n        tokens.push({\n          type: TY_STOP,\n          cp\n        });\n      } else if (VALID.has(cp)) {\n        tokens.push({\n          type: TY_VALID,\n          cps: [cp]\n        });\n      } else if (IGNORED.has(cp)) {\n        tokens.push({\n          type: TY_IGNORED,\n          cp\n        });\n      } else {\n        let cps = MAPPED.get(cp);\n        if (cps) {\n          tokens.push({\n            type: TY_MAPPED,\n            cp,\n            cps: cps.slice()\n          });\n        } else {\n          tokens.push({\n            type: TY_DISALLOWED,\n            cp\n          });\n        }\n      }\n    }\n  }\n  if (nf) {\n    for (let i = 0, start = -1; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (is_valid_or_mapped(token.type)) {\n        if (requires_check(token.cps)) {\n          // normalization might be needed\n          let end = i + 1;\n          for (let pos = end; pos < tokens.length; pos++) {\n            // find adjacent text\n            let {\n              type,\n              cps\n            } = tokens[pos];\n            if (is_valid_or_mapped(type)) {\n              if (!requires_check(cps)) break;\n              end = pos + 1;\n            } else if (type !== TY_IGNORED) {\n              // || type !== TY_DISALLOWED) { \n              break;\n            }\n          }\n          if (start < 0) start = i;\n          let slice = tokens.slice(start, end);\n          let cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\n          let cps = nfc(cps0);\n          if (compare_arrays(cps, cps0)) {\n            // bundle into an nfc token\n            tokens.splice(start, end - start, {\n              type: TY_NFC,\n              input: cps0,\n              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\n              cps,\n              tokens0: collapse_valid_tokens(slice),\n              tokens: ens_tokenize(str_from_cps(cps), {\n                nf: false\n              })\n            });\n            i = start;\n          } else {\n            i = end - 1; // skip to end of slice\n          }\n          start = -1; // reset\n        } else {\n          start = i; // remember last\n        }\n      } else if (token.type !== TY_IGNORED) {\n        // 20221024: is this correct?\n        start = -1; // reset\n      }\n    }\n  }\n  return collapse_valid_tokens(tokens);\n}\nfunction is_valid_or_mapped(type) {\n  return type == TY_VALID || type == TY_MAPPED;\n}\nfunction requires_check(cps) {\n  return cps.some(cp => NFC_CHECK.has(cp));\n}\nfunction collapse_valid_tokens(tokens) {\n  for (let i = 0; i < tokens.length; i++) {\n    if (tokens[i].type == TY_VALID) {\n      let j = i + 1;\n      while (j < tokens.length && tokens[j].type == TY_VALID) j++;\n      tokens.splice(i, j - i, {\n        type: TY_VALID,\n        cps: tokens.slice(i, j).flatMap(x => x.cps)\n      });\n    }\n  }\n  return tokens;\n}\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };","map":{"version":3,"names":["decode_arithmetic","bytes","pos","u16","symbol_count","total","acc","i","push","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","HALF","QRTR","MASK","register","symbols","low","range","value","Math","floor","start","end","mid","a","b","offset","map","x","read_payload","v","read_compressed_payload","s","unsafe_atob","lookup","forEach","c","charCodeAt","n","length","ret","Uint8Array","width","carry","signed","read_deltas","next","Array","read_sorted","prev","read_sorted_arrays","read_array_while","read_mapped","w","read_linear_table","read_replacement_table","flat","read_transposed","m","fill","j","dx","dy","vN","flatMap","ys","_","j_dy","y","slice","r","FENCED","Map","hex_cp","cp","toString","toUpperCase","padStart","quote_cp","explode_cp","cps","len","codePointAt","str_from_cps","chunk","String","fromCodePoint","buf","join","compare_arrays","nf","form","normalize","nfc","nfd","STOP","FE0F","STOP_CH","UNIQUE_PH","HYPHEN","read_set","Set","MAPPED","IGNORED","CM","ESCAPE","NFC_CHECK","CHUNKS","read_chunked","UNRESTRICTED","GROUPS","R","P","Q","V","sort","M","WHOLE_VALID","WHOLE_MAP","d","has","set","values","recs","gs","filter","g","rec","find","G","some","add","union","complement","multi","VALID","EMOJI_SORTED","EMOJI_ROOT","read_emoji_trie","B","keys","size","temp","F","S","C","Emoji","is_emoji","safe_str_from_cps","quoter","is_combining_mark","should_escape","quoted_cp","check_label_extension","Error","check_leading_underscore","UNDERSCORE","lastIndexOf","check_fenced","get","error_placement","last","match","ens_normalize_fragment","frag","decompose","split","label","process","filter_fe0f","ens_normalize","name","flatten","ens_split","ens_beautify","type","output","error","indexOf","preserve_emoji","input","info","norm","tokens","token_count","chars","emoji","every","unique","determine_group","check_group","check_whole","err","group","maker","shared","whole","groups","error_disallowed","error_group_member","msg","message","quoted","gg","where","decomposed","e","reverse","consume_emoji_reversed","pop","eaten","node","saved","stack","conform_emoji_copy","copy","from","splice","ens_emoji","build","br","TY_VALID","TY_MAPPED","TY_IGNORED","TY_DISALLOWED","TY_EMOJI","TY_NFC","TY_STOP","ens_tokenize","token","is_valid_or_mapped","requires_check","cps0","tokens0","collapse_valid_tokens"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/node_modules/@adraffy/ens-normalize/dist/index-xnf.js"],"sourcesContent":["function decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\n\n// created 2023-01-26T08:54:35.886Z\nvar r = read_compressed_payload('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');\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// reverse polyfill\r\n\r\nfunction nf(cps, form) {\r\n\treturn explode_cp(str_from_cps(cps).normalize(form));\r\n}\r\n\r\nfunction nfc(cps) {\r\n\treturn nf(cps, 'NFC');\r\n}\r\nfunction nfd(cps) {\r\n\treturn nf(cps, 'NFD');\r\n}\n\n//const t0 = performance.now();\r\n\r\nconst STOP = 0x2E;\r\nconst FE0F = 0xFE0F;\r\nconst STOP_CH = '.';\r\nconst UNIQUE_PH = 1;\r\nconst HYPHEN = 0x2D;\r\n\r\nfunction read_set() {\r\n\treturn new Set(read_sorted(r));\r\n}\r\nconst MAPPED = new Map(read_mapped(r)); \r\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\r\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\r\nconst CM = read_set();\r\nconst ESCAPE = read_set(); // characters that should not be printed\r\nconst NFC_CHECK = read_set();\r\nconst CHUNKS = read_sorted_arrays(r);\r\nfunction read_chunked() {\r\n\t// deduplicated sets + uniques\r\n\treturn new Set([read_sorted(r).map(i => CHUNKS[i]), read_sorted(r)].flat(2));\r\n}\r\nconst UNRESTRICTED = r();\r\nconst GROUPS = read_array_while(i => {\r\n\t// minifier property mangling seems unsafe\r\n\t// so these are manually renamed to single chars\r\n\tlet N = read_array_while(r).map(x => x+0x60);\r\n\tif (N.length) {\r\n\t\tlet R = i >= UNRESTRICTED; // first arent restricted\r\n\t\tN[0] -= 32; // capitalize\r\n\t\tN = str_from_cps(N);\r\n\t\tif (R) N=`Restricted[${N}]`;\r\n\t\tlet P = read_chunked(); // primary\r\n\t\tlet Q = read_chunked(); // secondary\r\n\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\tlet M = r()-1; // combining mark\r\n\t\t// code currently isn't needed\r\n\t\t/*if (M < 0) { // whitelisted\r\n\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\tlet i = r();\r\n\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t})];\r\n\t\t\t}));\r\n\t\t}*/\r\n\t\treturn {N, P, M, R, V: new Set(V)};\r\n\t}\r\n});\r\nconst WHOLE_VALID = read_set();\r\nconst WHOLE_MAP = new Map();\r\n// decode compressed wholes\r\n[...WHOLE_VALID, ...read_set()].sort((a, b) => a-b).map((cp, i, v) => {\r\n\tlet d = r(); \r\n\tlet w = v[i] = d ? v[i-d] : {V: [], M: new Map()};\r\n\tw.V.push(cp); // add to member set\r\n\tif (!WHOLE_VALID.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t}\r\n});\r\n// compute confusable-extent complements\r\nfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t// connect all groups that have each whole character\r\n\tlet recs = [];\r\n\tfor (let cp of V) {\r\n\t\tlet gs = GROUPS.filter(g => g.V.has(cp));\r\n\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\tif (!rec) {\r\n\t\t\trec = {G: new Set(), V: []};\r\n\t\t\trecs.push(rec);\r\n\t\t}\r\n\t\trec.V.push(cp);\r\n\t\tgs.forEach(g => rec.G.add(g));\r\n\t}\r\n\t// per character cache groups which are not a member of the extent\r\n\tlet union = recs.flatMap(({G}) => [...G]);\r\n\tfor (let {G, V} of recs) {\r\n\t\tlet complement = new Set(union.filter(g => !G.has(g)));\r\n\t\tfor (let cp of V) {\r\n\t\t\tM.set(cp, complement);\r\n\t\t}\r\n\t}\r\n}\r\nlet union = new Set(); // exists in 1+ groups\r\nlet multi = new Set(); // exists in 2+ groups\r\nfor (let g of GROUPS) {\r\n\tfor (let cp of g.V) {\r\n\t\t(union.has(cp) ? multi : union).add(cp);\r\n\t}\r\n}\r\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\nfor (let cp of union) {\r\n\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t}\r\n}\r\nconst VALID = new Set([...union, ...nfd(union)]); // possibly valid\r\n\r\n// decode emoji\r\nconst EMOJI_SORTED = read_sorted(r);\r\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\r\nconst EMOJI_ROOT = read_emoji_trie([]);\r\nfunction read_emoji_trie(cps) {\r\n\tlet B = read_array_while(() => {\r\n\t\tlet keys = read_sorted(r).map(i => EMOJI_SORTED[i]);\r\n\t\tif (keys.length) return read_emoji_trie(keys);\r\n\t}).sort((a, b) => b.Q.size - a.Q.size); // sort by likelihood\r\n\tlet temp = r();\r\n\tlet V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\r\n\ttemp = (temp / 3)|0;\r\n\tlet F = temp & 1; // allow FE0F\r\n\ttemp >>= 1;\r\n\tlet S = temp & 1; // save\r\n\tlet C = temp & 2; // check\r\n\treturn {B, V, F, S, C, Q: new Set(cps)};\r\n}\r\n//console.log(performance.now() - t0);\r\n\r\n// free tagging system\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; }\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `\"${safe_str_from_cps([cp])}\" `) + quote_cp(cp);\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error('invalid label extension');\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1;\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\nfunction is_combining_mark(cp) {\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf).flatMap(x => x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(ens_split(name));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet split = ens_split(name, true);\r\n\t// this is experimental\r\n\tfor (let {type, output, error} of split) {\r\n\t\tif (error) continue;\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') { \r\n\t\t\tlet prev = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet next = output.indexOf(0x3BE, prev);\r\n\t\t\t\tif (next < 0) break;\r\n\t\t\t\toutput[next] = 0x39E; \r\n\t\t\t\tprev = next + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(split);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria 4.1 Rule 4\r\n\t// \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\tlet norm;\r\n\t\ttry {\r\n\t\t\tlet tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens[0];\r\n\t\t\t\tlet emoji = token_count > 1 || chars.is_emoji;\r\n\t\t\t\tif (!emoji && chars.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t\tnorm = chars;\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\t// only needed for ascii\r\n\t\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\t\tcheck_label_extension(norm);\r\n\t\t\t\t\t// cant have fenced\r\n\t\t\t\t\t// cant have cm\r\n\t\t\t\t\t// cant have wholes\r\n\t\t\t\t\t// see derive: assert ascii fast path\r\n\t\t\t\t\ttype = 'ASCII';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (emoji) { // there is at least one emoji\r\n\t\t\t\t\t\tinfo.emoji = true; \r\n\t\t\t\t\t\tchars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnorm = tokens.flatMap(x => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\t\tlet unique = [...new Set(chars)];\r\n\t\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\tinfo.output = norm;\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = []; // TODO: can this be avoided?\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : [...set];\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaning groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => g.V.has(cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => g.V.has(cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (groups === GROUPS) {\r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label \"${safe_str_from_cps(input)}\": ${msg}`);\r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp));\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\nfunction check_group(g, cps) {\r\n\tlet {V, M} = g;\r\n\tfor (let cp of cps) {\r\n\t\tif (!V.has(cp)) {\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\tif (M >= 0) {\r\n\t\t// we know it can't be cm leading\r\n\t\t// we know the previous character isn't an emoji\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) {\r\n\t\t\tif (CM.has(cps[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} \"${str_from_cps(cps.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(cps[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(cps.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\nfunction process(input, nf) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(emoji);\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps);\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// allows optional FE0F\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet saved;\r\n\tlet stack = [];\r\n\tlet pos = cps.length;\r\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\r\n\twhile (pos) {\r\n\t\tlet cp = cps[--pos];\r\n\t\tnode = node.B.find(x => x.Q.has(cp));\r\n\t\tif (!node) break;\r\n\t\tif (node.S) { // remember\r\n\t\t\tsaved = cp;\r\n\t\t} else if (node.C) { // check exclusion\r\n\t\t\tif (cp === saved) break;\r\n\t\t}\r\n\t\tstack.push(cp);\r\n\t\tif (node.F) {\r\n\t\t\tstack.push(FE0F);\r\n\t\t\tif (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\r\n\t\t}\r\n\t\tif (node.V) { // this is a valid emoji (so far)\r\n\t\t\temoji = conform_emoji_copy(stack, node);\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t// *** this code currently isn't needed ***\r\n\tif (!emoji) {\r\n\t\tlet cp = cps[cps.length-1];\r\n\t\tif (EMOJI_SOLO.has(cp)) {\r\n\t\t\tif (eaten) eaten.push(cp);\r\n\t\t\temoji = Emoji.of(cp);\r\n\t\t\tcps.pop();\r\n\t\t}\r\n\t}\r\n\t*/\r\n\treturn emoji;\r\n}\r\n\r\n// create a copy and fix any unicode quirks\r\nfunction conform_emoji_copy(cps, node) {\r\n\tlet copy = Emoji.from(cps); // copy stack\r\n\tif (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\r\n\treturn copy;\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\t// *** this code currently isn't needed ***\r\n\t//let ret = [...EMOJI_SOLO].map(x => [x]);\r\n\tlet ret = [];\r\n\tbuild(EMOJI_ROOT, []);\r\n\treturn ret.sort(compare_arrays);\r\n\tfunction build(node, cps, saved) {\r\n\t\tif (node.S) { \r\n\t\t\tsaved = cps[cps.length-1];\r\n\t\t} else if (node.C) { \r\n\t\t\tif (saved === cps[cps.length-1]) return;\r\n\t\t}\r\n\t\tif (node.F) cps.push(FE0F);\r\n\t\tif (node.V) ret.push(conform_emoji_copy(cps, node));\r\n\t\tfor (let br of node.B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\tbuild(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\t\t\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({type: TY_EMOJI, emoji, input: eaten.slice(), cps: filter_fe0f(emoji)});\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\nexport { ens_beautify, ens_emoji, ens_normalize, ens_normalize_fragment, ens_split, ens_tokenize, is_combining_mark, nfc, nfd, safe_str_from_cps, should_escape };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}