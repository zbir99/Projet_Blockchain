{"ast":null,"code":"/**\n * Simulation d'IPFS pour le développement sans IPFS local\n * Cette version génère des hashes aléatoires et stocke les fichiers en mémoire\n */\n\n// Stockage en mémoire pour simuler IPFS\nconst mockIPFSStorage = new Map();\n\n/**\n * Génère un hash aléatoire pour simuler un CID IPFS\n * @returns {string} - Hash simulé\n */\nconst generateMockHash = () => {\n  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  let hash = 'Qm';\n  for (let i = 0; i < 44; i++) {\n    hash += characters.charAt(Math.floor(Math.random() * characters.length));\n  }\n  return hash;\n};\n\n/**\n * Télécharge un fichier sur le stockage simulé IPFS\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS simulé du fichier\n */\nexport const uploadToIPFS = async file => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n\n    // Générer un hash simulé\n    const mockHash = generateMockHash();\n\n    // Stocker le fichier en mémoire (pour la simulation)\n    const fileURL = URL.createObjectURL(file);\n    mockIPFSStorage.set(mockHash, {\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      url: fileURL\n    });\n    console.log(`Fichier \"${file.name}\" téléchargé avec succès (simulation IPFS)`);\n    console.log(`Hash simulé: ${mockHash}`);\n\n    // Simuler un délai réseau pour rendre l'expérience plus réaliste\n    await new Promise(resolve => setTimeout(resolve, 500));\n    return mockHash;\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS (simulé):', error);\n    throw error;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur la passerelle IPFS simulée\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = ipfsHash => {\n  if (!ipfsHash) return '';\n\n  // Vérifier si le hash existe dans notre stockage simulé\n  if (mockIPFSStorage.has(ipfsHash)) {\n    return mockIPFSStorage.get(ipfsHash).url;\n  }\n\n  // Fallback pour les tests - renvoie une URL qui ne fonctionnera pas\n  // mais qui permettra de voir le hash dans l'interface\n  return `http://localhost:8080/ipfs/${ipfsHash}`;\n};\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};","map":{"version":3,"names":["mockIPFSStorage","Map","generateMockHash","characters","hash","i","charAt","Math","floor","random","length","uploadToIPFS","file","Error","mockHash","fileURL","URL","createObjectURL","set","name","type","size","url","console","log","Promise","resolve","setTimeout","error","getIPFSGatewayURL","ipfsHash","has","get"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/src/utils/ipfs.js"],"sourcesContent":["/**\n * Simulation d'IPFS pour le développement sans IPFS local\n * Cette version génère des hashes aléatoires et stocke les fichiers en mémoire\n */\n\n// Stockage en mémoire pour simuler IPFS\nconst mockIPFSStorage = new Map();\n\n/**\n * Génère un hash aléatoire pour simuler un CID IPFS\n * @returns {string} - Hash simulé\n */\nconst generateMockHash = () => {\n  const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  let hash = 'Qm';\n  for (let i = 0; i < 44; i++) {\n    hash += characters.charAt(Math.floor(Math.random() * characters.length));\n  }\n  return hash;\n};\n\n/**\n * Télécharge un fichier sur le stockage simulé IPFS\n * @param {File} file - Le fichier à télécharger\n * @returns {Promise<string>} - Le hash IPFS simulé du fichier\n */\nexport const uploadToIPFS = async (file) => {\n  try {\n    // Vérification que le fichier est valide\n    if (!file) {\n      throw new Error('Aucun fichier fourni');\n    }\n    \n    // Générer un hash simulé\n    const mockHash = generateMockHash();\n    \n    // Stocker le fichier en mémoire (pour la simulation)\n    const fileURL = URL.createObjectURL(file);\n    mockIPFSStorage.set(mockHash, {\n      name: file.name,\n      type: file.type,\n      size: file.size,\n      url: fileURL\n    });\n    \n    console.log(`Fichier \"${file.name}\" téléchargé avec succès (simulation IPFS)`); \n    console.log(`Hash simulé: ${mockHash}`);\n    \n    // Simuler un délai réseau pour rendre l'expérience plus réaliste\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    return mockHash;\n  } catch (error) {\n    console.error('Erreur lors du téléchargement sur IPFS (simulé):', error);\n    throw error;\n  }\n};\n\n/**\n * Génère l'URL pour accéder au fichier sur la passerelle IPFS simulée\n * @param {string} ipfsHash - Le hash IPFS du fichier\n * @returns {string} - L'URL complète pour accéder au fichier\n */\nexport const getIPFSGatewayURL = (ipfsHash) => {\n  if (!ipfsHash) return '';\n  \n  // Vérifier si le hash existe dans notre stockage simulé\n  if (mockIPFSStorage.has(ipfsHash)) {\n    return mockIPFSStorage.get(ipfsHash).url;\n  }\n  \n  // Fallback pour les tests - renvoie une URL qui ne fonctionnera pas\n  // mais qui permettra de voir le hash dans l'interface\n  return `http://localhost:8080/ipfs/${ipfsHash}`;\n};\n\nexport default {\n  uploadToIPFS,\n  getIPFSGatewayURL\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA,MAAMA,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAEjC;AACA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAGA,CAAA,KAAM;EAC7B,MAAMC,UAAU,GAAG,sCAAsC;EACzD,IAAIC,IAAI,GAAG,IAAI;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;IAC3BD,IAAI,IAAID,UAAU,CAACG,MAAM,CAACC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGN,UAAU,CAACO,MAAM,CAAC,CAAC;EAC1E;EACA,OAAON,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMO,YAAY,GAAG,MAAOC,IAAI,IAAK;EAC1C,IAAI;IACF;IACA,IAAI,CAACA,IAAI,EAAE;MACT,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;IACzC;;IAEA;IACA,MAAMC,QAAQ,GAAGZ,gBAAgB,CAAC,CAAC;;IAEnC;IACA,MAAMa,OAAO,GAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC;IACzCZ,eAAe,CAACkB,GAAG,CAACJ,QAAQ,EAAE;MAC5BK,IAAI,EAAEP,IAAI,CAACO,IAAI;MACfC,IAAI,EAAER,IAAI,CAACQ,IAAI;MACfC,IAAI,EAAET,IAAI,CAACS,IAAI;MACfC,GAAG,EAAEP;IACP,CAAC,CAAC;IAEFQ,OAAO,CAACC,GAAG,CAAC,YAAYZ,IAAI,CAACO,IAAI,4CAA4C,CAAC;IAC9EI,OAAO,CAACC,GAAG,CAAC,gBAAgBV,QAAQ,EAAE,CAAC;;IAEvC;IACA,MAAM,IAAIW,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,GAAG,CAAC,CAAC;IAEtD,OAAOZ,QAAQ;EACjB,CAAC,CAAC,OAAOc,KAAK,EAAE;IACdL,OAAO,CAACK,KAAK,CAAC,kDAAkD,EAAEA,KAAK,CAAC;IACxE,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,GAAIC,QAAQ,IAAK;EAC7C,IAAI,CAACA,QAAQ,EAAE,OAAO,EAAE;;EAExB;EACA,IAAI9B,eAAe,CAAC+B,GAAG,CAACD,QAAQ,CAAC,EAAE;IACjC,OAAO9B,eAAe,CAACgC,GAAG,CAACF,QAAQ,CAAC,CAACR,GAAG;EAC1C;;EAEA;EACA;EACA,OAAO,8BAA8BQ,QAAQ,EAAE;AACjD,CAAC;AAED,eAAe;EACbnB,YAAY;EACZkB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}