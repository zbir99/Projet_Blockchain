{"ast":null,"code":"import * as cborg from 'cborg';\nimport { CID } from 'multiformats/cid';\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42;\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView(buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength);\n  }\n  return buf;\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null; // any other kind of object\n  }\n  const cid = CID.asCID(obj);\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null;\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1); // prefix is 0x00, for historical reasons\n  return [new cborg.Token(cborg.Type.tag, CID_CBOR_TAG), new cborg.Token(cborg.Type.bytes, bytes)];\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n};\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n  return CID.decode(bytes.subarray(1)); // ignore leading 0x00\n}\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n};\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n};\nexport const name = 'dag-cbor';\nexport const code = 0x71;\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = node => cborg.encode(node, _encodeOptions);\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = data => cborg.decode(toByteView(data), _decodeOptions);","map":{"version":3,"names":["cborg","CID","CID_CBOR_TAG","toByteView","buf","ArrayBuffer","Uint8Array","byteLength","cidEncoder","obj","asCID","bytes","cid","set","Token","Type","tag","undefinedEncoder","Error","numberEncoder","num","Number","isNaN","Infinity","_encodeOptions","float64","typeEncoders","Object","undefined","number","encodeOptions","cidDecoder","decode","subarray","_decodeOptions","allowIndefinite","coerceUndefinedToNull","allowNaN","allowInfinity","allowBigInt","strict","useMaps","rejectDuplicateMapKeys","tags","decodeOptions","slice","name","code","encode","node","data"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/node_modules/@ipld/dag-cbor/src/index.js"],"sourcesContent":["import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}