{"ast":null,"code":"/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg';\nimport * as cborgJson from 'cborg/json';\nimport { CID } from 'multiformats';\nimport { base64 } from 'multiformats/bases/base64';\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView(buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength);\n  }\n  return buf;\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null; // any other kind of object\n  }\n  const cid = CID.asCID(obj);\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null;\n  }\n  const cidString = cid.toString();\n  return [new Token(Type.map, Infinity, 1), new Token(Type.string, '/', 1),\n  // key\n  new Token(Type.string, cidString, cidString.length),\n  // value\n  new Token(Type.break, undefined, 1)];\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder(bytes) {\n  const bytesString = base64.encode(bytes).slice(1); // no mbase prefix\n  return [new Token(Type.map, Infinity, 1), new Token(Type.string, '/', 1),\n  // key\n  new Token(Type.map, Infinity, 1),\n  // value\n  new Token(Type.string, 'bytes', 5),\n  // inner key\n  new Token(Type.string, bytesString, bytesString.length),\n  // inner value\n  new Token(Type.break, undefined, 1), new Token(Type.break, undefined, 1)];\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder(obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder(ab) {\n  return bytesEncoder(new Uint8Array(ab));\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null; // process with standard number encoder\n}\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor(data, options) {\n    super(data, options);\n    /** @type {Token[]} */\n    this.tokenBuffer = [];\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done() {\n    return this.tokenBuffer.length === 0 && super.done();\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next() {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop();\n    }\n    return super.next();\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next() {\n    const token = this._next();\n    if (token.type === Type.map) {\n      const keyToken = this._next();\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next();\n        if (valueToken.type === Type.string) {\n          // *must* be a CID\n          const breakToken = this._next(); // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form');\n          }\n          this.tokenBuffer.push(valueToken); // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0);\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next();\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next();\n            if (innerValueToken.type === Type.string) {\n              // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next(); // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form');\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`);\n              return new Token(Type.bytes, bytes, innerValueToken.value.length);\n            }\n            this.tokenBuffer.push(innerValueToken); // bail\n          }\n          this.tokenBuffer.push(innerKeyToken); // bail\n        }\n        this.tokenBuffer.push(valueToken); // bail\n      }\n      this.tokenBuffer.push(keyToken); // bail\n    }\n    return token;\n  }\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n};\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse;\nexport const name = 'dag-json';\nexport const code = 0x0129;\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = node => cborgJson.encode(node, encodeOptions);\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = data => {\n  const buf = toByteView(data);\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, {\n    tokenizer: new DagJsonTokenizer(buf, decodeOptions)\n  });\n  return cborgJson.decode(buf, options);\n};\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = node => utf8Decoder.decode(encode(node));\nexport { format as stringify };\nconst utf8Decoder = new TextDecoder();\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = data => decode(utf8Encoder.encode(data));\nconst utf8Encoder = new TextEncoder();","map":{"version":3,"names":["Token","Type","cborgJson","CID","base64","toByteView","buf","ArrayBuffer","Uint8Array","byteLength","cidEncoder","obj","asCID","bytes","cid","cidString","toString","map","Infinity","string","length","break","undefined","bytesEncoder","bytesString","encode","slice","taBytesEncoder","buffer","byteOffset","abBytesEncoder","ab","undefinedEncoder","Error","numberEncoder","num","Number","isNaN","encodeOptions","typeEncoders","Object","Buffer","Int8Array","Uint16Array","Int16Array","Uint32Array","Int32Array","Float32Array","Float64Array","Uint8ClampedArray","BigInt64Array","BigUint64Array","DataView","number","DagJsonTokenizer","Tokenizer","constructor","data","options","tokenBuffer","done","_next","pop","next","token","type","keyToken","value","valueToken","breakToken","push","tag","innerKeyToken","innerValueToken","i","decode","decodeOptions","allowIndefinite","allowUndefined","allowNaN","allowInfinity","allowBigInt","strict","useMaps","rejectDuplicateMapKeys","tags","parse","name","code","node","assign","tokenizer","format","utf8Decoder","stringify","TextDecoder","utf8Encoder","TextEncoder"],"sources":["C:/Users/yassi/OneDrive/Desktop/tp_9/Certification-de-Diplomes/node_modules/@ipld/dag-json/src/index.js"],"sourcesContent":["/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  const buf = toByteView(data)\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(buf, decodeOptions) })\n  return cborgJson.decode(buf, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}