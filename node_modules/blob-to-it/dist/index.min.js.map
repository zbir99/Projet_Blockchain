{
  "version": 3,
  "sources": ["../src/index.ts", "../../browser-readablestream-to-it/src/index.ts"],
  "sourcesContent": ["/**\n * @packageDocumentation\n *\n * Allows reading Blob contents as an async iterator.\n *\n * @example\n *\n * ```javascript\n * import toIt from 'blob-to-it'\n * import all from 'it-all'\n *\n * const content = [ Uint8Array.from([0, 1, 2, 3, 4]) ]\n * const blob = new Blob(content)\n * const arr = await all(toIt(blob))\n *\n * console.info(arr) // [ [ 0, 1, 2, 3, 4 ] ]\n * ```\n */\n\nimport browserReadableStreamToIt from 'browser-readablestream-to-it'\n\nexport default function blobToIt (blob: Blob): AsyncIterable<Uint8Array> {\n  if (typeof blob.stream === 'function') {\n    return browserReadableStreamToIt(blob.stream())\n  }\n\n  // firefox < 69 does not support blob.stream()\n  // @ts-expect-error - response.body is optional, but in practice it's a stream.\n  return browserReadableStreamToIt(new Response(blob).body)\n}\n", "/**\n * @packageDocumentation\n *\n * Allows treating a browser readable stream as an async iterator.\n *\n * @example\n *\n * ```javascript\n * import toIt from 'browser-readablestream-to-it'\n * import all from 'it-all'\n *\n * const content = [0, 1, 2, 3, 4]\n *\n * const stream = new ReadableStream({\n *   start(controller) {\n *     for (let i = 0; i < content.length; i++) {\n *       controller.enqueue(content[i])\n *     }\n *\n *     controller.close()\n *   }\n * })\n *\n * const arr = await all(toIt(stream))\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n *\n * ## preventCancel\n *\n * By default a readable stream will have [.cancel](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/cancel) called on it once it has ended or\n * reading has stopped prematurely.\n *\n * To prevent this behaviour, pass `preventCancel: true` as an option:\n *\n * ```javascript\n * const arr = await all(toIt(stream, { preventCancel: true }))\n *\n * console.info(arr) // 0, 1, 2, 3, 4\n * ```\n */\n\nexport interface BrowserReadableStreamToItOptions {\n  preventCancel?: boolean\n}\n\n/**\n * Turns a browser readable stream into an async iterable. Async iteration over\n * returned iterable will lock give stream, preventing any other consumer from\n * acquiring a reader. The lock will be released if iteration loop is broken. To\n * prevent stream cancelling optional `{ preventCancel: true }` could be passed\n * as a second argument.\n */\nexport default async function * browserReadableStreamToIt <T> (stream: ReadableStream<T>, options: BrowserReadableStreamToItOptions = {}): AsyncGenerator<T, void, undefined> {\n  const reader = stream.getReader()\n\n  try {\n    while (true) {\n      const result = await reader.read()\n\n      if (result.done) {\n        return\n      }\n\n      yield result.value\n    }\n  } finally {\n    if (options.preventCancel !== true) {\n      await reader.cancel()\n    }\n\n    reader.releaseLock()\n  }\n}\n"],
  "mappings": ";4bAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,ICqDA,eAAOC,EAAwDC,EAA2BC,EAA4C,CAAA,EAAE,CACtI,IAAMC,EAASF,EAAO,UAAS,EAE/B,GAAI,CACF,OAAa,CACX,IAAMG,EAAS,MAAMD,EAAO,KAAI,EAEhC,GAAIC,EAAO,KACT,OAGF,MAAMA,EAAO,KACf,CACF,SACMF,EAAQ,gBAAkB,IAC5B,MAAMC,EAAO,OAAM,EAGrBA,EAAO,YAAW,CACpB,CACF,CDpDc,SAAPE,EAA2BC,EAAU,CAC1C,OAAI,OAAOA,EAAK,QAAW,WAClBC,EAA0BD,EAAK,OAAM,CAAE,EAKzCC,EAA0B,IAAI,SAASD,CAAI,EAAE,IAAI,CAC1D",
  "names": ["index_exports", "__export", "blobToIt", "browserReadableStreamToIt", "stream", "options", "reader", "result", "blobToIt", "blob", "browserReadableStreamToIt"]
}
